#ifndef _REAPER_PLUGIN_FUNCTIONS_H_
#define _REAPER_PLUGIN_FUNCTIONS_H_

// REAPER API functions
// Generated by REAPER v4.581

/*
*  Copyright 2006-2013, Cockos Incorporated
*
*  This software is provided 'as-is', without any express or implied
*  warranty.  In no event will the authors be held liable for any damages
*  arising from the use of this software.
*
*  Permission is granted to anyone to use this software for any purpose,
*  including commercial applications, and to alter it and redistribute it
*  freely, subject to the following restrictions:
*
*  1. The origin of this software must not be misrepresented; you must not
*     claim that you wrote the original software. If you use this software
*     in a product, an acknowledgment in the product documentation would be
*     appreciated but is not required.
*  2. Altered source versions must be plainly marked as such, and must not be
*     misrepresented as being the original software.
*  3. This notice may not be removed or altered from any source distribution.
*/

// Note: the C++ pure virtual interfaces used require the MSVC-compatible C++ ABI on Win32.  Sorry, mingw users.
//
// Reaper extensions: see http://www.cockos.com/reaper/sdk/plugin/plugin.php and reaper_plugin.h.
// The API functions in this header can be retrieved using reaper_plugin_info_t.GetFunc().
//
// VST plugins: see http://www.cockos.com/reaper/sdk/vst/vst_ext.php
// The API functions in this header can be retrieved using audioMasterCallback.
//
// Because the API is dynamic, callers should never assume a function exists.
// Check that a non-NULL function pointer was returned before using it.

#ifndef _LICE_H
typedef unsigned int LICE_pixel;
typedef unsigned char LICE_pixel_chan;
class LICE_IBitmap;
class LICE_IFont;
#endif

class WDL_VirtualWnd_BGCfg;

// easiest to include reaper_plugin.h before reaper_plugin_functions.h in your application code.
// if not, you may need to edit this path.
#ifndef _REAPER_PLUGIN_H_
#include "reaper_plugin.h"
#endif

#ifndef REAPERAPI_DECL
#define REAPERAPI_DECL extern
#endif

// __mergesort is a stable sorting function with an API similar to qsort().
// HOWEVER, it requires some temporary space, equal to the size of the data being sorted, so you can pass it as the last parameter,
// or NULL and it will allocate and free space internally.
REAPERAPI_DECL void (*__mergesort)(void* base, size_t nmemb, size_t size, int (*cmpfunc)(const void*,const void*), void* tmpspace);

// menuidstr is some unique identifying string
// menuname is for main menus only (displayed in a menu bar somewhere), NULL otherwise
// kbdsecname is the name of the KbdSectionInfo registered by this plugin, or NULL for the main actions section
REAPERAPI_DECL bool (*AddCustomizableMenu)(const char* menuidstr, const char* menuname, const char* kbdsecname, bool addtomainmenu);

// Add an Extensions main menu, which the extension can populate/modify with plugin_register("hookcustommenu")
REAPERAPI_DECL bool (*AddExtensionsMainMenu)();

// creates a new media item.
REAPERAPI_DECL MediaItem* (*AddMediaItemToTrack)(MediaTrack* tr);

// Returns the index of the created marker/region, or -1 on failure. Supply wantidx>=0 if you want a particular index number, but you'll get a different index number a region and wantidx is already in use.
REAPERAPI_DECL int (*AddProjectMarker)(ReaProject* proj, bool isrgn, double pos, double rgnend, const char* name, int wantidx);

// Returns the index of the created marker/region, or -1 on failure. Supply wantidx>=0 if you want a particular index number, but you'll get a different index number a region and wantidx is already in use. color should be 0 or RGB(x,y,z)|0x1000000
REAPERAPI_DECL int (*AddProjectMarker2)(ReaProject* proj, bool isrgn, double pos, double rgnend, const char* name, int wantidx, int color);

// creates a new take in an item
REAPERAPI_DECL MediaItem_Take* (*AddTakeToMediaItem)(MediaItem* item);

// Deprecated. Use SetTempoTimeSigMarker with ptidx=-1.
REAPERAPI_DECL bool (*AddTempoTimeSigMarker)(ReaProject* proj, double timepos, double bpm, int timesig_num, int timesig_denom, bool lineartempochange);

// forceset=0,doupd=true,centermode=-1 for default
REAPERAPI_DECL void (*adjustZoom)(double amt, int forceset, bool doupd, int centermode);

REAPERAPI_DECL bool (*AnyTrackSolo)(ReaProject* proj);

REAPERAPI_DECL void (*APITest)();

// nudgeflag: &1=set to value (otherwise nudge by value), &2=snap
// nudgewhat: 0=position, 1=left trim, 2=left edge, 3=right edge, 4=contents, 5=duplicate, 6=edit cursor
// nudgeunit: 0=ms, 1=seconds, 2=grid, 3=256th notes, ..., 15=whole notes, 16=measures.beats (1.15 = 1 measure + 1.5 beats), 17=samples, 18=frames, 19=pixels, 20=item lengths, 21=item selections
// value: amount to nudge by, or value to set to
// reverse: in nudge mode, nudges left (otherwise ignored)
// copies: in nudge duplicate mode, number of copies (otherwise ignored)
REAPERAPI_DECL bool (*ApplyNudge)(ReaProject* project, int nudgeflag, int nudgewhat, int nudgeunits, double value, bool reverse, int copies);

// is in pre-buffer? threadsafe
REAPERAPI_DECL int (*Audio_IsPreBuffer)();

// is audio running at all? threadsafe
REAPERAPI_DECL int (*Audio_IsRunning)();

// return >0 on success
REAPERAPI_DECL int (*Audio_RegHardwareHook)(bool isAdd, audio_hook_register_t* reg);

// -1 = bypass all if not all bypassed,otherwise unbypass all
REAPERAPI_DECL void (*BypassFxAllTracks)(int bypass);

REAPERAPI_DECL int (*CalculatePeaks)(PCM_source_transfer_t* srcBlock, PCM_source_peaktransfer_t* pksBlock);

// NOTE: source samples field is a pointer to floats instead
REAPERAPI_DECL int (*CalculatePeaksFloatSrcPtr)(PCM_source_transfer_t* srcBlock, PCM_source_peaktransfer_t* pksBlock);

REAPERAPI_DECL void (*ClearAllRecArmed)();

// resets the global peak caches
REAPERAPI_DECL void (*ClearPeakCache)();

// Returns the number of shortcuts that exist for the given command ID.
// see GetActionShortcutDesc, DeleteActionShortcut, DoActionShortcutDialog.
REAPERAPI_DECL int (*CountActionShortcuts)(KbdSectionInfo* section, int cmdID);

// count the number of items in the project (proj=0 for active project)
REAPERAPI_DECL int (*CountMediaItems)(ReaProject* proj);

// count the number of selected items in the project (proj=0 for active project)
REAPERAPI_DECL int (*CountSelectedMediaItems)(ReaProject* proj);

// count the number of selected tracks in the project (proj=0 for active project)
REAPERAPI_DECL int (*CountSelectedTracks)(ReaProject* proj);

// count the number of takes in the item
REAPERAPI_DECL int (*CountTakes)(MediaItem* item);

// Count the number of FX parameter knobs displayed on the track control panel.
REAPERAPI_DECL int (*CountTCPFXParms)(ReaProject* project, MediaTrack* track);

// Count the number of tempo/time signature markers in the project. See GetTempoTimeSigMarker, SetTempoTimeSigMarker, AddTempoTimeSigMarker.
REAPERAPI_DECL int (*CountTempoTimeSigMarkers)(ReaProject* proj);

// see GetTrackEnvelope
REAPERAPI_DECL int (*CountTrackEnvelopes)(MediaTrack* track);

// count the number of items in the track
REAPERAPI_DECL int (*CountTrackMediaItems)(MediaTrack* track);

// count the number of tracks in the project (proj=0 for active project)
REAPERAPI_DECL int (*CountTracks)(ReaProject* proj);

// callback is a function pointer: void (*callback)(void* obj, const char* msg, int msglen), which handles OSC messages sent from REAPER. The function return is a local osc handler. See SendLocalOscMessage, DestroyOscHandler.
REAPERAPI_DECL void* (*CreateLocalOscHandler)(void* obj, void* callback);

REAPERAPI_DECL midi_Input* (*CreateMIDIInput)(int dev);

REAPERAPI_DECL midi_Output* (*CreateMIDIOutput)(int dev, bool streamMode, int* msoffset100);

// Create a new MIDI media item, containing no MIDI events.
REAPERAPI_DECL MediaItem* (*CreateNewMIDIItemInProj)(double starttime, double endtime);

// Create an audio accessor object for this take. See CreateTrackAudioAccessor, DestroyAudioAccessor, GetAudioAccessorHash, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.
REAPERAPI_DECL void* (*CreateTakeAudioAccessor)(MediaItem_Take* take);

// Create an audio accessor object for this track. See CreateTakeAudioAccessor, DestroyAudioAccessor, GetAudioAccessorHash, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.
REAPERAPI_DECL void* (*CreateTrackAudioAccessor)(MediaTrack* track);

// call this to force flushing of the undo states after using CSurf_On*Change()
REAPERAPI_DECL void (*CSurf_FlushUndo)(bool force);

REAPERAPI_DECL bool (*CSurf_GetTouchState)(MediaTrack* trackid, int isPan);

REAPERAPI_DECL void (*CSurf_GoEnd)();

REAPERAPI_DECL void (*CSurf_GoStart)();

REAPERAPI_DECL int (*CSurf_NumTracks)(bool mcpView);

REAPERAPI_DECL void (*CSurf_OnArrow)(int whichdir, bool wantzoom);

REAPERAPI_DECL void (*CSurf_OnFwd)(int seekplay);

REAPERAPI_DECL bool (*CSurf_OnFXChange)(MediaTrack* trackid, int en);

REAPERAPI_DECL int (*CSurf_OnInputMonitorChange)(MediaTrack* trackid, int monitor);

REAPERAPI_DECL int (*CSurf_OnInputMonitorChangeEx)(MediaTrack* trackid, int monitor, bool allowgang);

REAPERAPI_DECL bool (*CSurf_OnMuteChange)(MediaTrack* trackid, int mute);

REAPERAPI_DECL bool (*CSurf_OnMuteChangeEx)(MediaTrack* trackid, int mute, bool allowgang);

REAPERAPI_DECL void (*CSurf_OnOscControlMessage)(const char* msg, const float* arg);

REAPERAPI_DECL double (*CSurf_OnPanChange)(MediaTrack* trackid, double pan, bool relative);

REAPERAPI_DECL double (*CSurf_OnPanChangeEx)(MediaTrack* trackid, double pan, bool relative, bool allowGang);

REAPERAPI_DECL void (*CSurf_OnPause)();

REAPERAPI_DECL void (*CSurf_OnPlay)();

REAPERAPI_DECL void (*CSurf_OnPlayRateChange)(double playrate);

REAPERAPI_DECL bool (*CSurf_OnRecArmChange)(MediaTrack* trackid, int recarm);

REAPERAPI_DECL bool (*CSurf_OnRecArmChangeEx)(MediaTrack* trackid, int recarm, bool allowgang);

REAPERAPI_DECL void (*CSurf_OnRecord)();

REAPERAPI_DECL double (*CSurf_OnRecvPanChange)(MediaTrack* trackid, int recv_index, double pan, bool relative);

REAPERAPI_DECL double (*CSurf_OnRecvVolumeChange)(MediaTrack* trackid, int recv_index, double volume, bool relative);

REAPERAPI_DECL void (*CSurf_OnRew)(int seekplay);

REAPERAPI_DECL void (*CSurf_OnRewFwd)(int seekplay, int dir);

REAPERAPI_DECL void (*CSurf_OnScroll)(int xdir, int ydir);

REAPERAPI_DECL bool (*CSurf_OnSelectedChange)(MediaTrack* trackid, int selected);

REAPERAPI_DECL double (*CSurf_OnSendPanChange)(MediaTrack* trackid, int send_index, double pan, bool relative);

REAPERAPI_DECL double (*CSurf_OnSendVolumeChange)(MediaTrack* trackid, int send_index, double volume, bool relative);

REAPERAPI_DECL bool (*CSurf_OnSoloChange)(MediaTrack* trackid, int solo);

REAPERAPI_DECL bool (*CSurf_OnSoloChangeEx)(MediaTrack* trackid, int solo, bool allowgang);

REAPERAPI_DECL void (*CSurf_OnStop)();

REAPERAPI_DECL void (*CSurf_OnTempoChange)(double bpm);

REAPERAPI_DECL void (*CSurf_OnTrackSelection)(MediaTrack* trackid);

REAPERAPI_DECL double (*CSurf_OnVolumeChange)(MediaTrack* trackid, double volume, bool relative);

REAPERAPI_DECL double (*CSurf_OnVolumeChangeEx)(MediaTrack* trackid, double volume, bool relative, bool allowGang);

REAPERAPI_DECL double (*CSurf_OnWidthChange)(MediaTrack* trackid, double width, bool relative);

REAPERAPI_DECL double (*CSurf_OnWidthChangeEx)(MediaTrack* trackid, double width, bool relative, bool allowGang);

REAPERAPI_DECL void (*CSurf_OnZoom)(int xdir, int ydir);

REAPERAPI_DECL void (*CSurf_ResetAllCachedVolPanStates)();

REAPERAPI_DECL void (*CSurf_ScrubAmt)(double amt);

REAPERAPI_DECL void (*CSurf_SetAutoMode)(int mode, IReaperControlSurface* ignoresurf);

REAPERAPI_DECL void (*CSurf_SetPlayState)(bool play, bool pause, bool rec, IReaperControlSurface* ignoresurf);

REAPERAPI_DECL void (*CSurf_SetRepeatState)(bool rep, IReaperControlSurface* ignoresurf);

REAPERAPI_DECL void (*CSurf_SetSurfaceMute)(MediaTrack* trackid, bool mute, IReaperControlSurface* ignoresurf);

REAPERAPI_DECL void (*CSurf_SetSurfacePan)(MediaTrack* trackid, double pan, IReaperControlSurface* ignoresurf);

REAPERAPI_DECL void (*CSurf_SetSurfaceRecArm)(MediaTrack* trackid, bool recarm, IReaperControlSurface* ignoresurf);

REAPERAPI_DECL void (*CSurf_SetSurfaceSelected)(MediaTrack* trackid, bool selected, IReaperControlSurface* ignoresurf);

REAPERAPI_DECL void (*CSurf_SetSurfaceSolo)(MediaTrack* trackid, bool solo, IReaperControlSurface* ignoresurf);

REAPERAPI_DECL void (*CSurf_SetSurfaceVolume)(MediaTrack* trackid, double volume, IReaperControlSurface* ignoresurf);

REAPERAPI_DECL void (*CSurf_SetTrackListChange)();

REAPERAPI_DECL MediaTrack* (*CSurf_TrackFromID)(int idx, bool mcpView);

REAPERAPI_DECL int (*CSurf_TrackToID)(MediaTrack* track, bool mcpView);

REAPERAPI_DECL double (*DB2SLIDER)(double x);

// Delete the specific shortcut for the given command ID.
// See CountActionShortcuts, GetActionShortcutDesc, DoActionShortcutDialog.
REAPERAPI_DECL bool (*DeleteActionShortcut)(KbdSectionInfo* section, int cmdID, int shortcutidx);

// Delete the extended state value for a specific section and key. persist=true means the value should remain deleted the next time REAPER is opened. See SetExtState, GetExtState, HasExtState.
REAPERAPI_DECL void (*DeleteExtState)(const char* section, const char* key, bool persist);

// Delete a marker.  proj==NULL for the active project.
REAPERAPI_DECL bool (*DeleteProjectMarker)(ReaProject* proj, int markrgnindexnumber, bool isrgn);

// deletes a track
REAPERAPI_DECL void (*DeleteTrack)(MediaTrack* tr);

REAPERAPI_DECL bool (*DeleteTrackMediaItem)(MediaTrack* tr, MediaItem* it);

// Destroy an audio accessor. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, GetAudioAccessorHash, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples. 
REAPERAPI_DECL void (*DestroyAudioAccessor)(void* accessor);

// See CreateLocalOscHandler, SendLocalOscMessage.
REAPERAPI_DECL void (*DestroyLocalOscHandler)(void* local_osc_handler);

// Open the action shortcut dialog to edit or add a shortcut for the given command ID. If (shortcutidx >= 0 && shortcutidx < CountActionShortcuts()), that specific shortcut will be replaced, otherwise a new shortcut will be added.
// See CountActionShortcuts, GetActionShortcutDesc, DeleteActionShortcut.
REAPERAPI_DECL bool (*DoActionShortcutDialog)(HWND hwnd, KbdSectionInfo* section, int cmdID, int shortcutidx);

// updates preference for docker window ident_str to be in dock whichDock on next open
REAPERAPI_DECL void (*Dock_UpdateDockID)(char* ident_str, int whichDock);

// returns dock index that contains hwnd, or -1
REAPERAPI_DECL int (*DockIsChildOfDock)(HWND hwnd, bool* isFloatingDocker);

REAPERAPI_DECL void (*DockWindowActivate)(HWND hwnd);

REAPERAPI_DECL void (*DockWindowAdd)(HWND hwnd, char* name, int pos, bool allowShow);

REAPERAPI_DECL void (*DockWindowAddEx)(HWND hwnd, char* name, char* identstr, bool allowShow);

REAPERAPI_DECL void (*DockWindowRefresh)();

REAPERAPI_DECL void (*DockWindowRefreshForHWND)(HWND hwnd);

REAPERAPI_DECL void (*DockWindowRemove)(HWND hwnd);

// Populate destmenu with all the entries and submenus found in srcmenu
REAPERAPI_DECL bool (*DuplicateCustomizableMenu)(void* srcmenu, void* destmenu);

// call with a saved window rect for your window and it'll correct any positioning info.
REAPERAPI_DECL void (*EnsureNotCompletelyOffscreen)(RECT* r);

// returns FALSE when done,sets out to NULL if a mode is currently unsupported
REAPERAPI_DECL bool (*EnumPitchShiftModes)(int idx, const char** out);

REAPERAPI_DECL const char* (*EnumPitchShiftSubModes)(int idx, int submode);

REAPERAPI_DECL int (*EnumProjectMarkers)(int idx, bool* isrgn, double* pos, double* rgnend, char** name, int* markrgnindexnumber);

REAPERAPI_DECL int (*EnumProjectMarkers2)(ReaProject* proj, int idx, bool* isrgn, double* pos, double* rgnend, char** name, int* markrgnindexnumber);

REAPERAPI_DECL int (*EnumProjectMarkers3)(ReaProject* proj, int idx, bool* isrgn, double* pos, double* rgnend, char** name, int* markrgnindexnumber, int* color);

// idx=-1 for current project,projfn can be NULL if not interested in filename
REAPERAPI_DECL ReaProject* (*EnumProjects)(int idx, char* projfn, int projfnlen);

// Enumerate which tracks will be rendered within this region when using the region render matrix. When called with rendertrack==0, the function returns the first track that will be rendered (which may be the master track); rendertrack==1 will return the next track rendered, and so on. The function returns NULL when there are no more tracks that will be rendered within this region.
REAPERAPI_DECL MediaTrack* (*EnumRegionRenderMatrix)(ReaProject* proj, int regionindex, int rendertrack);

// returns false if there are no plugins on the track that support MIDI programs,or if all programs have been enumerated
REAPERAPI_DECL bool (*EnumTrackMIDIProgramNames)(int track, int programNumber, char* programName, int maxnamelen);

// returns false if there are no plugins on the track that support MIDI programs,or if all programs have been enumerated
REAPERAPI_DECL bool (*EnumTrackMIDIProgramNamesEx)(ReaProject* proj, MediaTrack* track, int programNumber, char* programName, int maxnamelen);

// returns true if path points to a valid, readable file
REAPERAPI_DECL bool (*file_exists)(const char* path);

// time formatting mode overrides: -1=proj default.
// 0=time
// 1=measures.beats + time
// 2=measures.beats
// 3=seconds
// 4=samples
// 5=h:m:s:f
REAPERAPI_DECL void (*format_timestr)(double tpos, char* buf, int buflen);

// time formatting mode overrides: -1=proj default.
// 0=time
// 1=measures.beats + time
// 2=measures.beats
// 3=seconds
// 4=samples
// 5=h:m:s:f
// offset is start of where the length will be calculated from
REAPERAPI_DECL void (*format_timestr_len)(double tpos, char* buf, int buflen, double offset, int modeoverride);

// time formatting mode overrides: -1=proj default.
// 0=time
// 1=measures.beats + time
// 2=measures.beats
// 3=seconds
// 4=samples
// 5=h:m:s:f
REAPERAPI_DECL void (*format_timestr_pos)(double tpos, char* buf, int buflen, int modeoverride);

// free heap memory returned from a Reaper API function
REAPERAPI_DECL void (*FreeHeapPtr)(void* ptr);

REAPERAPI_DECL void (*genGuid)(GUID* g);

REAPERAPI_DECL void* (*get_config_var)(const char* name, int* szout);

REAPERAPI_DECL const char* (*get_ini_file)();

REAPERAPI_DECL void* (*get_midi_config_var)(const char* name, int* szout);

// Get the text description of a specific shortcut for the given command ID.
// See CountActionShortcuts,DeleteActionShortcut,DoActionShortcutDialog.
REAPERAPI_DECL bool (*GetActionShortcutDesc)(KbdSectionInfo* section, int cmdID, int shortcutidx, char* desc, int desclen);

// get the active take in this item
REAPERAPI_DECL MediaItem_Take* (*GetActiveTake)(MediaItem* item);

REAPERAPI_DECL const char* (*GetAppVersion)();

// Get the end time of the audio that can be returned from this accessor. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, GetAudioAccessorHash, GetAudioAccessorStartTime, GetAudioAccessorSamples.
REAPERAPI_DECL double (*GetAudioAccessorEndTime)(void* accessor);

// Get a short hash string (128 chars or less) that will change only if the underlying samples change.  See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.
REAPERAPI_DECL void (*GetAudioAccessorHash)(void* accessor, char* hash);

// Get a block of samples from the audio accessor. Samples are extracted immediately pre-FX, and returned interleaved (first sample of first channel, first sample of second channel...). Returns 0 if no audio, 1 if audio, -1 on error. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, GetAudioAccessorHash, GetAudioAccessorStartTime, GetAudioAccessorEndTime.
REAPERAPI_DECL int (*GetAudioAccessorSamples)(void* accessor, int samplerate, int numchannels, double starttime_sec, int numsamplesperchannel, double* samplebuffer);

// Get the start time of the audio that can be returned from this accessor. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, GetAudioAccessorHash, GetAudioAccessorEndTime, GetAudioAccessorSamples.
REAPERAPI_DECL double (*GetAudioAccessorStartTime)(void* accessor);

// deprecated?
REAPERAPI_DECL INT_PTR (*GetColorTheme)(int idx, int defval);

// returns the whole color theme (icontheme.h) and the size
REAPERAPI_DECL void* (*GetColorThemeStruct)(int* sz);

// gets the dock ID desired by ident_str, if any
REAPERAPI_DECL int (*GetConfigWantsDock)(char* ident_str);

// gets context menus. submenu 0:trackctl, 1:mediaitems, 2:ruler, 3:empty track area
REAPERAPI_DECL HMENU (*GetContextMenu)(int idx);

// returns current project if in load/save (usually only used from project_config_extension_t)
REAPERAPI_DECL void* (*GetCurrentProjectInLoadSave)();

// 0 if track panels, 1 if items, 2 if envelopes, otherwise unknown
REAPERAPI_DECL int (*GetCursorContext)();

// edit cursor position
REAPERAPI_DECL double (*GetCursorPosition)();

// edit cursor position
REAPERAPI_DECL double (*GetCursorPositionEx)(ReaProject* proj);

// returns the custom take, item, or track color that is used (according to the user preference) to color the media item.  The color is returned as 0x01RRGGBB, so a return of zero means "no color", not black.
REAPERAPI_DECL int (*GetDisplayedMediaItemColor)(MediaItem* item);

// returns the custom take, item, or track color that is used (according to the user preference) to color the media item.  The color is returned as 0x01RRGGBB, so a return of zero means "no color", not black.
REAPERAPI_DECL int (*GetDisplayedMediaItemColor2)(MediaItem* item, MediaItem_Take* take);

REAPERAPI_DECL bool (*GetEnvelopeName)(TrackEnvelope* env, char* buf, int maxlen);

// returns path of REAPER.exe (not including EXE),i.e. C:\Program Files\REAPER
REAPERAPI_DECL const char* (*GetExePath)();

// Get the extended state value for a specific section and key. See SetExtState, DeleteExtState, HasExtState.
REAPERAPI_DECL const char* (*GetExtState)(const char* section, const char* key);

// Returns 1 if a track FX window has focus, 2 if an item FX window has focus, 0 if no FX window has focus. tracknumber==0 means the master track, 1 means track 1, etc. itemnumber and fxnumber are zero-based. See GetLastTouchedFX.
REAPERAPI_DECL bool (*GetFocusedFX)(int* tracknumber, int* itemnumber, int* fxnumber);

// returns pixels/second
REAPERAPI_DECL double (*GetHZoomLevel)();

// returns a named icontheme entry
REAPERAPI_DECL void* (*GetIconThemePointer)(const char* name);

// returns the whole icon theme (icontheme.h) and the size
REAPERAPI_DECL void* (*GetIconThemeStruct)(int* sz);

REAPERAPI_DECL const char* (*GetInputChannelName)(int idx);

// returns time of relevant edit, set which_item to the pcm_source (if applicable), flags (if specified) will be set to 1 for edge resizing, 2 for fade change, 4 for item move
REAPERAPI_DECL double (*GetItemEditingTime2)(PCM_source** which_item, int* flags);

REAPERAPI_DECL void* (*GetItemProjectContext)(MediaItem* item);

// Returns true if the last touched FX parameter is valid, false otherwise. tracknumber==0 means the master track, 1 means track 1, etc. fxnumber and paramnumber are zero-based. See GetFocusedFX.
REAPERAPI_DECL bool (*GetLastTouchedFX)(int* tracknumber, int* fxnumber, int* paramnumber);

REAPERAPI_DECL MediaTrack* (*GetLastTouchedTrack)();

REAPERAPI_DECL HWND (*GetMainHwnd)();

// &1=master mute,&2=master solo. This is deprecated as you can just query the master track as well.
REAPERAPI_DECL int (*GetMasterMuteSoloFlags)();

REAPERAPI_DECL MediaTrack* (*GetMasterTrack)(ReaProject* proj);

// returns &1 if the master track is visible in the TCP, &2 if visible in the mixer. See SetMasterTrackVisibility.
REAPERAPI_DECL int (*GetMasterTrackVisibility)();

// returns max dev for midi inputs/outputs
REAPERAPI_DECL int (*GetMaxMidiInputs)();

REAPERAPI_DECL int (*GetMaxMidiOutputs)();

// get an item from a project by item count (zero-based) (proj=0 for active project)
REAPERAPI_DECL MediaItem* (*GetMediaItem)(ReaProject* proj, int itemidx);

// Get parent track of media item
REAPERAPI_DECL MediaTrack* (*GetMediaItem_Track)(MediaItem* item);

// Get media item numerical-value attributes.
// B_MUTE : bool * to muted state
// B_LOOPSRC : bool * to loop source
// B_ALLTAKESPLAY : bool * to all takes play
// B_UISEL : bool * to ui selected
// C_BEATATTACHMODE : char * to one char of beat attached mode, -1=def, 0=time, 1=allbeats, 2=beatsosonly
// C_LOCK : char * to one char of lock flags (&1 is locked, currently)
// D_VOL : double * of item volume (volume bar)
// D_POSITION : double * of item position (seconds)
// D_LENGTH : double * of item length (seconds)
// D_SNAPOFFSET : double * of item snap offset (seconds)
// D_FADEINLEN : double * of item fade in length (manual, seconds)
// D_FADEOUTLEN : double * of item fade out length (manual, seconds)
// D_FADEINLEN_AUTO : double * of item autofade in length (seconds, -1 for no autofade set)
// D_FADEOUTLEN_AUTO : double * of item autofade out length (seconds, -1 for no autofade set)
// C_FADEINSHAPE : int * to fadein shape, 0=linear, ...
// C_FADEOUTSHAPE : int * to fadeout shape
// I_GROUPID : int * to group ID (0 = no group)
// I_LASTY : int * to last y position in track (readonly)
// I_LASTH : int * to last height in track (readonly)
// I_CUSTOMCOLOR : int * : custom color, windows standard color order (i.e. RGB(r,g,b)|0x100000). if you do not |0x100000, then it will not be used (though will store the color anyway)
// I_CURTAKE : int * to active take
// IP_ITEMNUMBER : int, item number within the track (read-only, returns the item number directly)F_FREEMODE_Y : float * to free mode y position (0..1)
// F_FREEMODE_H : float * to free mode height (0..1)
REAPERAPI_DECL double (*GetMediaItemInfo_Value)(MediaItem* item, const char* parmname);

REAPERAPI_DECL int (*GetMediaItemNumTakes)(MediaItem* item);

REAPERAPI_DECL MediaItem_Take* (*GetMediaItemTake)(MediaItem* item, int tk);

// Get parent item of media item take
REAPERAPI_DECL MediaItem* (*GetMediaItemTake_Item)(MediaItem_Take* take);

// Get media source of media item take
REAPERAPI_DECL PCM_source* (*GetMediaItemTake_Source)(MediaItem_Take* take);

// Get parent track of media item take
REAPERAPI_DECL MediaTrack* (*GetMediaItemTake_Track)(MediaItem_Take* take);

REAPERAPI_DECL MediaItem_Take* (*GetMediaItemTakeByGUID)(ReaProject* project, GUID*  guid);

// Get media item take numerical-value attributes.
// D_STARTOFFS : double *, start offset in take of item
// D_VOL : double *, take volume
// D_PAN : double *, take pan
// D_PANLAW : double *, take pan law (-1.0=default, 0.5=-6dB, 1.0=+0dB, etc)
// D_PLAYRATE : double *, take playrate (1.0=normal, 2.0=doublespeed, etc)
// D_PITCH : double *, take pitch adjust (in semitones, 0.0=normal, +12 = one octave up, etc)
// B_PPITCH, bool *, preserve pitch when changing rate
// I_CHANMODE, int *, channel mode (0=normal, 1=revstereo, 2=downmix, 3=l, 4=r)
// I_PITCHMODE, int *, pitch shifter mode, -1=proj default, otherwise high word=shifter low word = parameter
// I_CUSTOMCOLOR : int *, custom color, windows standard color order (i.e. RGB(r,g,b)|0x100000). if you do not |0x100000, then it will not be used (though will store the color anyway)
// IP_TAKENUMBER : int, take number within the item (read-only, returns the take number directly)
REAPERAPI_DECL double (*GetMediaItemTakeInfo_Value)(MediaItem_Take* take, const char* parmname);

REAPERAPI_DECL MediaTrack* (*GetMediaItemTrack)(MediaItem* item);

// Copies the media source filename to typebuf. Note that in-project MIDI media sources have no associated filename.
REAPERAPI_DECL void (*GetMediaSourceFileName)(PCM_source* source, char* filenamebuf, int buflen);

// Returns the number of channels in the source media.
REAPERAPI_DECL int (*GetMediaSourceNumChannels)(PCM_source* source);

// Returns the sample rate. MIDI source media will return zero.
REAPERAPI_DECL int (*GetMediaSourceSampleRate)(PCM_source* source);

// copies the media source type ("WAV", "MIDI", etc) to typebuf
REAPERAPI_DECL void (*GetMediaSourceType)(PCM_source* source, char* typebuf, int buflen);

// Get track numerical-value attributes.
// B_MUTE : bool * : mute flag
// B_PHASE : bool * : invert track phase
// IP_TRACKNUMBER : int : track number (returns zero if not found, -1 for master track) (read-only, returns the int directly)
// I_SOLO : int * : 0=not soloed, 1=solo, 2=soloed in place
// I_FXEN : int * : 0=fx bypassed, nonzero = fx active
// I_RECARM : int * : 0=not record armed, 1=record armed
// I_RECINPUT : int * : record input. <0 = no input, 0..n = mono hardware input, 512+n = rearoute input, 1024 set for stereo input pair. 4096 set for MIDI input, if set, then low 5 bits represent channel (0=all, 1-16=only chan), then next 5 bits represent physical input (31=all, 30=VKB)
// I_RECMODE : int * : record mode (0=input, 1=stereo out, 2=none, 3=stereo out w/latcomp, 4=midi output, 5=mono out, 6=mono out w/ lat comp, 7=midi overdub, 8=midi replace
// I_RECMON : int * : record monitor (0=off, 1=normal, 2=not when playing (tapestyle))
// I_RECMONITEMS : int * : monitor items while recording (0=off, 1=on)
// I_AUTOMODE : int * : track automation mode (0=trim/off, 1=read, 2=touch, 3=write, 4=latch
// I_NCHAN : int * : number of track channels, must be 2-64, even
// I_SELECTED : int * : track selected? 0 or 1
// I_WNDH : int * : current TCP window height (Read-only)
// I_FOLDERDEPTH : int * : folder depth change (0=normal, 1=track is a folder parent, -1=track is the last in the innermost folder, -2=track is the last in the innermost and next-innermost folders, etc
// I_FOLDERCOMPACT : int * : folder compacting (only valid on folders), 0=normal, 1=small, 2=tiny children
// I_MIDIHWOUT : int * : track midi hardware output index (<0 for disabled, low 5 bits are which channels (0=all, 1-16), next 5 bits are output device index (0-31))
// I_PERFFLAGS : int * : track perf flags (&1=no media buffering, &2=no anticipative FX)
// I_CUSTOMCOLOR : int * : custom color, windows standard color order (i.e. RGB(r,g,b)|0x100000). if you do not |0x100000, then it will not be used (though will store the color anyway)
// I_HEIGHTOVERRIDE : int * : custom height override for TCP window. 0 for none, otherwise size in pixels
// D_VOL : double * : trim volume of track (0 (-inf)..1 (+0dB) .. 2 (+6dB) etc ..)
// D_PAN : double * : trim pan of track (-1..1)
// D_WIDTH : double * : width of track (-1..1)
// D_DUALPANL : double * : dualpan position 1 (-1..1), only if I_PANMODE==6
// D_DUALPANR : double * : dualpan position 2 (-1..1), only if I_PANMODE==6
// I_PANMODE : int * : pan mode (0 = classic 3.x, 3=new balance, 5=stereo pan, 6 = dual pan)
// D_PANLAW : double * : pan law of track. <0 for project default, 1.0 for +0dB, etc
// P_ENV : read only, returns TrackEnvelope *, setNewValue=<VOLENV, <PANENV, etc
// B_SHOWINMIXER : bool * : show track panel in mixer -- do not use on master
// B_SHOWINTCP : bool * : show track panel in tcp -- do not use on master
// B_MAINSEND : bool * : track sends audio to parent
// B_FREEMODE : bool * : track free-mode enabled (requires UpdateTimeline() after changing etc)
// C_BEATATTACHMODE : char * : char * to one char of beat attached mode, -1=def, 0=time, 1=allbeats, 2=beatsposonly
// F_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0.0=smallest allowed, 1=max allowed)
// F_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the fx+send total area (0=min allow, 1=max)
REAPERAPI_DECL double (*GetMediaTrackInfo_Value)(MediaTrack* tr, const char* parmname);

REAPERAPI_DECL midi_Input* (*GetMidiInput)(int idx);

// returns true if device present
REAPERAPI_DECL bool (*GetMIDIInputName)(int dev, char* nameout, int nameoutlen);

REAPERAPI_DECL midi_Output* (*GetMidiOutput)(int idx);

// returns true if device present
REAPERAPI_DECL bool (*GetMIDIOutputName)(int dev, char* nameout, int nameoutlen);

// Get the leftmost track visible in the mixer
REAPERAPI_DECL MediaTrack* (*GetMixerScroll)();

// Get the current mouse modifier assignment for a specific modifier key assignment, in a specific context.
// action will be filled in with the command ID number for a built-in mouse modifier
// or built-in REAPER command ID, or the custom action ID string.
// See SetMouseModifier for more information.
REAPERAPI_DECL void (*GetMouseModifier)(const char* context, int modifier_flag, char* action, int actionlen);

// Return number of normal audio hardware inputs available
REAPERAPI_DECL int (*GetNumAudioInputs)();

// Return number of normal audio hardware outputs available
REAPERAPI_DECL int (*GetNumAudioOutputs)();

// returns max number of real midi hardware inputs
REAPERAPI_DECL int (*GetNumMIDIInputs)();

// returns max number of real midi hardware outputs
REAPERAPI_DECL int (*GetNumMIDIOutputs)();

REAPERAPI_DECL int (*GetNumTracks)();

REAPERAPI_DECL const char* (*GetOutputChannelName)(int idx);

// returns output latency in seconds
REAPERAPI_DECL double (*GetOutputLatency)();

REAPERAPI_DECL MediaTrack* (*GetParentTrack)(MediaTrack* track);

// get the peak file name for a given file (can be either filename.reapeaks,or a hashed filename in another path)
REAPERAPI_DECL void (*GetPeakFileName)(const char* fn, char* buf, int bufmax);

// see note in reaper_plugin.h about PCM_source_peaktransfer_t::samplerate
REAPERAPI_DECL void* (*GetPeaksBitmap)(PCM_source_peaktransfer_t* pks, double maxamp, int w, int h, LICE_IBitmap* bmp);

// returns latency-compensated actual-what-you-hear position
REAPERAPI_DECL double (*GetPlayPosition)();

// returns position of next audio block being processed
REAPERAPI_DECL double (*GetPlayPosition2)();

// returns position of next audio block being processed
REAPERAPI_DECL double (*GetPlayPosition2Ex)(ReaProject* proj);

// returns latency-compensated actual-what-you-hear position
REAPERAPI_DECL double (*GetPlayPositionEx)(void* proj);

// &1=playing,&2=pause,&=4 is recording
REAPERAPI_DECL int (*GetPlayState)();

// &1=playing,&2=pause,&=4 is recording
REAPERAPI_DECL int (*GetPlayStateEx)(ReaProject* proj);

REAPERAPI_DECL void (*GetProjectPath)(char* buf, int bufsz);

REAPERAPI_DECL void (*GetProjectPathEx)(ReaProject* proj, char* buf, int bufsz);

// returns an integer that changes when the project state changes
REAPERAPI_DECL int (*GetProjectStateChangeCount)(ReaProject* proj);

// deprecated
REAPERAPI_DECL void (*GetProjectTimeSignature)(double* bpm, double* bpi);

// Gets basic time signature (beats per minute, numerator of time signature in bpi)
// this does not reflect tempo envelopes but is purely what is set in the project settings.
REAPERAPI_DECL void (*GetProjectTimeSignature2)(ReaProject* proj, double* bpm, double* bpi);

// returns path where ini files are stored, other things are in subdirectories.
REAPERAPI_DECL const char* (*GetResourcePath)();

// get a selected item by selected item count (zero-based) (proj=0 for active project)
REAPERAPI_DECL MediaItem* (*GetSelectedMediaItem)(ReaProject* proj, int selitem);

// get a selected track from a project by selected track count (zero-based) (proj=0 for active project)
REAPERAPI_DECL MediaTrack* (*GetSelectedTrack)(ReaProject* proj, int seltrackidx);

// get the currently selected track envelope, returns 0 if no envelope is selected
REAPERAPI_DECL TrackEnvelope* (*GetSelectedTrackEnvelope)(ReaProject* proj);

REAPERAPI_DECL void (*GetSet_ArrangeView2)(ReaProject* proj, bool isSet, int screen_x_start, int screen_x_end, double* start_time, double* end_time);

REAPERAPI_DECL void (*GetSet_LoopTimeRange)(bool isSet, bool isLoop, double* start, double* end, bool allowautoseek);

REAPERAPI_DECL void (*GetSet_LoopTimeRange2)(ReaProject* proj, bool isSet, bool isLoop, double* start, double* end, bool allowautoseek);

// get or set the state of an envelope as an xml/rpp chunk.
// supply str="" to get the state returned in str.
// the returned state string is limited to maxlen characters.
// supply str as an xml/rpp string to set the object state.
// returns true on success.
REAPERAPI_DECL bool (*GetSetEnvelopeState)(TrackEnvelope* env, char* str, int maxlen);

// get or set the state of an envelope as an xml/rpp chunk.
// set isundo if the state will be used for undo purposes (which may allow REAPER to get the state more efficiently)
// supply str="" to get the state returned in str.
// the returned state string is limited to maxlen characters.
// supply str as an xml/rpp string to set the object state.
// returns true on success.
REAPERAPI_DECL bool (*GetSetEnvelopeState2)(TrackEnvelope* env, char* str, int maxlen, bool isundo);

// get or set the state of a media item as an xml/rpp chunk.
// supply str="" to get the state returned in str.
// the returned state string is limited to maxlen characters.
// supply str as an xml/rpp string to set the object state.
// returns true on success.
REAPERAPI_DECL bool (*GetSetItemState)(MediaItem* item, char* str, int maxlen);

// get or set the state of a media item as an xml/rpp chunk.
// set isundo if the state will be used for undo purposes (which may allow REAPER to get the state more efficiently)
// supply str="" to get the state returned in str.
// the returned state string is limited to maxlen characters.
// supply str as an xml/rpp string to set the object state.
// returns true on success.
REAPERAPI_DECL bool (*GetSetItemState2)(MediaItem* item, char* str, int maxlen, bool isundo);

// P_TRACK : MediaTrack * (read only)
// P_NOTES : char * : item note text (do not write to returned pointer, use setNewValue to update)
// B_MUTE : bool * to muted state
// B_LOOPSRC : bool * to loop source
// B_ALLTAKESPLAY : bool * to all takes play
// B_UISEL : bool * to ui selected
// C_BEATATTACHMODE : char * to one char of beat attached mode, -1=def, 0=time, 1=allbeats, 2=beatsosonly
// C_LOCK : char * to one char of lock flags (&1 is locked, currently)
// D_VOL : double * of item volume (volume bar)
// D_POSITION : double * of item position (seconds)
// D_LENGTH : double * of item length (seconds)
// D_SNAPOFFSET : double * of item snap offset (seconds)
// D_FADEINLEN : double * of item fade in length (manual, seconds)
// D_FADEOUTLEN : double * of item fade out length (manual, seconds)
// D_FADEINLEN_AUTO : double * of item autofade in length (seconds, -1 for no autofade set)
// D_FADEOUTLEN_AUTO : double * of item autofade out length (seconds, -1 for no autofade set)
// C_FADEINSHAPE : int * to fadein shape, 0=linear, ...
// C_FADEOUTSHAPE : int * to fadeout shape
// I_GROUPID : int * to group ID (0 = no group)
// I_LASTY : int * to last y position in track (readonly)
// I_LASTH : int * to last height in track (readonly)
// I_CUSTOMCOLOR : int * : custom color, windows standard color order (i.e. RGB(r,g,b)|0x100000). if you do not |0x100000, then it will not be used (though will store the color anyway)
// I_CURTAKE : int * to active take
// IP_ITEMNUMBER : int, item number within the track (read-only, returns the item number directly)F_FREEMODE_Y : float * to free mode y position (0..1)
// F_FREEMODE_H : float * to free mode height (0..1)
REAPERAPI_DECL void* (*GetSetMediaItemInfo)(MediaItem* item, const char* parmname, void* setNewValue);

// P_TRACK : pointer to MediaTrack (read-only)
// P_ITEM : pointer to MediaItem (read-only)
// P_SOURCE : PCM_source *. Note that if setting this, you should first retrieve the old source, set the new, THEN delete the old.
// GUID : GUID * : 16-byte GUID, can query or update
// P_NAME : char * to take name
// D_STARTOFFS : double *, start offset in take of item
// D_VOL : double *, take volume
// D_PAN : double *, take pan
// D_PANLAW : double *, take pan law (-1.0=default, 0.5=-6dB, 1.0=+0dB, etc)
// D_PLAYRATE : double *, take playrate (1.0=normal, 2.0=doublespeed, etc)
// D_PITCH : double *, take pitch adjust (in semitones, 0.0=normal, +12 = one octave up, etc)
// B_PPITCH, bool *, preserve pitch when changing rate
// I_CHANMODE, int *, channel mode (0=normal, 1=revstereo, 2=downmix, 3=l, 4=r)
// I_PITCHMODE, int *, pitch shifter mode, -1=proj default, otherwise high word=shifter low word = parameter
// I_CUSTOMCOLOR : int *, custom color, windows standard color order (i.e. RGB(r,g,b)|0x100000). if you do not |0x100000, then it will not be used (though will store the color anyway)
// IP_TAKENUMBER : int, take number within the item (read-only, returns the take number directly)
REAPERAPI_DECL void* (*GetSetMediaItemTakeInfo)(MediaItem_Take* tk, const char* parmname, void* setNewValue);

// P_NAME : char * to take name
REAPERAPI_DECL bool (*GetSetMediaItemTakeInfo_String)(MediaItem_Take* tk, const char* parmname, char* string, bool setnewvalue);

// Get or set track attributes.
// P_PARTRACK : MediaTrack * : parent track (read-only)
// GUID : GUID * : 16-byte GUID, can query or update (do not use on master though)
// P_NAME : char * : track name (on master returns NULL)
// 
// B_MUTE : bool * : mute flag
// B_PHASE : bool * : invert track phase
// IP_TRACKNUMBER : int : track number (returns zero if not found, -1 for master track) (read-only, returns the int directly)
// I_SOLO : int * : 0=not soloed, 1=solo, 2=soloed in place
// I_FXEN : int * : 0=fx bypassed, nonzero = fx active
// I_RECARM : int * : 0=not record armed, 1=record armed
// I_RECINPUT : int * : record input. <0 = no input, 0..n = mono hardware input, 512+n = rearoute input, 1024 set for stereo input pair. 4096 set for MIDI input, if set, then low 5 bits represent channel (0=all, 1-16=only chan), then next 5 bits represent physical input (31=all, 30=VKB)
// I_RECMODE : int * : record mode (0=input, 1=stereo out, 2=none, 3=stereo out w/latcomp, 4=midi output, 5=mono out, 6=mono out w/ lat comp, 7=midi overdub, 8=midi replace
// I_RECMON : int * : record monitor (0=off, 1=normal, 2=not when playing (tapestyle))
// I_RECMONITEMS : int * : monitor items while recording (0=off, 1=on)
// I_AUTOMODE : int * : track automation mode (0=trim/off, 1=read, 2=touch, 3=write, 4=latch
// I_NCHAN : int * : number of track channels, must be 2-64, even
// I_SELECTED : int * : track selected? 0 or 1
// I_WNDH : int * : current TCP window height (Read-only)
// I_FOLDERDEPTH : int * : folder depth change (0=normal, 1=track is a folder parent, -1=track is the last in the innermost folder, -2=track is the last in the innermost and next-innermost folders, etc
// I_FOLDERCOMPACT : int * : folder compacting (only valid on folders), 0=normal, 1=small, 2=tiny children
// I_MIDIHWOUT : int * : track midi hardware output index (<0 for disabled, low 5 bits are which channels (0=all, 1-16), next 5 bits are output device index (0-31))
// I_PERFFLAGS : int * : track perf flags (&1=no media buffering, &2=no anticipative FX)
// I_CUSTOMCOLOR : int * : custom color, windows standard color order (i.e. RGB(r,g,b)|0x100000). if you do not |0x100000, then it will not be used (though will store the color anyway)
// I_HEIGHTOVERRIDE : int * : custom height override for TCP window. 0 for none, otherwise size in pixels
// D_VOL : double * : trim volume of track (0 (-inf)..1 (+0dB) .. 2 (+6dB) etc ..)
// D_PAN : double * : trim pan of track (-1..1)
// D_WIDTH : double * : width of track (-1..1)
// D_DUALPANL : double * : dualpan position 1 (-1..1), only if I_PANMODE==6
// D_DUALPANR : double * : dualpan position 2 (-1..1), only if I_PANMODE==6
// I_PANMODE : int * : pan mode (0 = classic 3.x, 3=new balance, 5=stereo pan, 6 = dual pan)
// D_PANLAW : double * : pan law of track. <0 for project default, 1.0 for +0dB, etc
// P_ENV : read only, returns TrackEnvelope *, setNewValue=<VOLENV, <PANENV, etc
// B_SHOWINMIXER : bool * : show track panel in mixer -- do not use on master
// B_SHOWINTCP : bool * : show track panel in tcp -- do not use on master
// B_MAINSEND : bool * : track sends audio to parent
// B_FREEMODE : bool * : track free-mode enabled (requires UpdateTimeline() after changing etc)
// C_BEATATTACHMODE : char * : char * to one char of beat attached mode, -1=def, 0=time, 1=allbeats, 2=beatsposonly
// F_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0.0=smallest allowed, 1=max allowed)
// F_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the fx+send total area (0=min allow, 1=max)
REAPERAPI_DECL void* (*GetSetMediaTrackInfo)(MediaTrack* tr, const char* parmname, void* setNewValue);

// Get or set track string attributes.
// P_NAME : char * : track name (on master returns NULL)
// 
REAPERAPI_DECL bool (*GetSetMediaTrackInfo_String)(MediaTrack* tr, const char* parmname, char* string, bool setnewvalue);

// get or set the state of a {track,item,envelope} as an xml/rpp chunk
// str="" to get the chunk string returned (must call FreeHeapPtr when done)
// supply str to set the state (returns zero)
REAPERAPI_DECL char* (*GetSetObjectState)(void* obj, const char* str);

// get or set the state of a {track,item,envelope} as an xml/rpp chunk
// str="" to get the chunk string returned (must call FreeHeapPtr when done)
// supply str to set the state (returns zero)
// set isundo if the state will be used for undo purposes (which may allow REAPER to get the state more efficiently
REAPERAPI_DECL char* (*GetSetObjectState2)(void* obj, const char* str, bool isundo);

// -1 == query,0=clear,1=set,>1=toggle . returns new value
REAPERAPI_DECL int (*GetSetRepeat)(int val);

// -1 == query,0=clear,1=set,>1=toggle . returns new value
REAPERAPI_DECL int (*GetSetRepeatEx)(ReaProject* proj, int val);

// Get or set the filename for storage of various track MIDI characteristics. 0=MIDI colormap image file, 1=MIDI bank/program select file, 2=MIDI text string file. If fn != NULL, a new track MIDI storage file will be set; otherwise the existing track MIDI storage file will be returned. 
REAPERAPI_DECL const char* (*GetSetTrackMIDISupportFile)(ReaProject* proj, void* track, int which, const char* filename);

// category is <0 for receives, 0=sends, >0 for hardware outputs
// sendidx is 0..n (NULL on any required parameter to stop)
// parameter names:
// P_DESTTRACK : read only, returns MediaTrack *, destination track, only applies for sends/recvs
// P_SRCTRACK : read only, returns MediaTrack *, source track, only applies for sends/recvs
// P_ENV : read only, returns TrackEnvelope *, setNewValue=<VOLENV, <PANENV, etc
// B_MUTE : returns bool *, read/write
// B_PHASE : returns bool *, read/write, true to flip phase
// B_MONO : returns bool *, read/write
// D_VOL : returns double *, read/write, 1.0 = +0dB etc
// D_PAN : returns double *, read/write, -1..+1
// D_PANLAW : returns double *,read/write, 1.0=+0.0db, 0.5=-6dB, -1.0 = projdef etc
// I_SENDMODE : returns int *, read/write, 0=post-fader, 1=pre-fx, 2=post-fx(depr), 3=post-fx
// I_SRCCHAN : returns int *, read/write, index,&1024=mono, -1 for none
// I_DSTCHAN : returns int *, read/write, index, &1024=mono, otherwise stereo pair, hwout:&512=rearoute
// I_MIDIFLAGS : returns int *, read/write, low 5 bits=source channel 0=all, 1-16, next 5 bits=dest channel, 0=orig, 1-16=chan
REAPERAPI_DECL void* (*GetSetTrackSendInfo)(MediaTrack* tr, int category, int sendidx, const char* parmname, void* setNewValue);

// get or set the state of a track as an xml/rpp chunk.
// supply str="" to get the state returned in str.
// the returned state string is limited to maxlen characters.
// supply str as an xml/rpp string to set the object state.
// returns true on success.
REAPERAPI_DECL bool (*GetSetTrackState)(MediaTrack* track, char* str, int maxlen);

// get or set the state of a track as an xml/rpp chunk.
// set isundo if the state will be used for undo purposes (which may allow REAPER to get the state more efficiently)
// supply str="" to get the state returned in str.
// the returned state string is limited to maxlen characters.
// supply str as an xml/rpp string to set the object state.
// returns true on success.
REAPERAPI_DECL bool (*GetSetTrackState2)(MediaTrack* track, char* str, int maxlen, bool isundo);

REAPERAPI_DECL ReaProject* (*GetSubProjectFromSource)(PCM_source* src);

// get a take from an item by take count (zero-based)
REAPERAPI_DECL MediaItem_Take* (*GetTake)(MediaItem* item, int takeidx);

REAPERAPI_DECL TrackEnvelope* (*GetTakeEnvelopeByName)(MediaItem_Take* take, const char* envname);

// returns NULL if the take is not valid
REAPERAPI_DECL const char* (*GetTakeName)(MediaItem_Take* take);

// Get information about a specific FX parameter knob (see CountTCPFXParms).
REAPERAPI_DECL bool (*GetTCPFXParm)(ReaProject* project, MediaTrack* track, int index, int* fxindex, int* parmidx);

// finds the playrate and target length to insert this item stretched to a round power-of-2 number of bars, between 1/8 and 256
REAPERAPI_DECL bool (*GetTempoMatchPlayRate)(PCM_source* source, double srcscale, double position, double mult, double* rate, double* targetlen);

// Get information about a tempo/time signature marker. See CountTempoTimeSigMarkers, SetTempoTimeSigMarker, AddTempoTimeSigMarker.
REAPERAPI_DECL bool (*GetTempoTimeSigMarker)(ReaProject* proj, int ptidx, double* timepos, int* measurepos, double* beatpos, double* bpm, int* timesig_num, int* timesig_denom, bool* lineartempo);

REAPERAPI_DECL int (*GetToggleCommandState)(int command_id);

// For the main action context, the MIDI editor, or the media explorer, returns the toggle state of the action. 0=off, 1=on, -1=NA because the action does not have on/off states.  For the MIDI editor, the action state for the most recently focused window will be returned.
REAPERAPI_DECL int (*GetToggleCommandState2)(KbdSectionInfo* section, int cmdID);

// gets a tooltip window,in case you want to ask it for font information. Can return NULL.
REAPERAPI_DECL HWND (*GetTooltipWindow)();

// get a track from a project by track count (zero-based) (proj=0 for active project)
REAPERAPI_DECL MediaTrack* (*GetTrack)(ReaProject* proj, int trackidx);

REAPERAPI_DECL int (*GetTrackAutomationMode)(MediaTrack* tr);

// Returns the track color, as 0x01RRGGBB. Black is returned as 0x01000000, no color setting is returned as 0.
REAPERAPI_DECL int (*GetTrackColor)(MediaTrack* track);

REAPERAPI_DECL TrackEnvelope* (*GetTrackEnvelope)(MediaTrack* track, int envidx);

REAPERAPI_DECL TrackEnvelope* (*GetTrackEnvelopeByName)(MediaTrack* track, const char* envname);

REAPERAPI_DECL GUID* (*GetTrackGUID)(MediaTrack* tr);

// gets track info (returns name).
// track index, -1=master, 0..n, or cast a MediaTrack* to int
// if flags is non-NULL, will be set to:
// &1=folder
// &2=selected
// &4=has fx enabled
// &8=muted
// &16=soloed
// &32=SIP'd (with &16)
// &64=rec armed
REAPERAPI_DECL const char* (*GetTrackInfo)(INT_PTR track, int* flags);

REAPERAPI_DECL MediaItem* (*GetTrackMediaItem)(MediaTrack* tr, int itemidx);

REAPERAPI_DECL const char* (*GetTrackMIDINoteName)(int track, int note, int chan);

REAPERAPI_DECL const char* (*GetTrackMIDINoteNameEx)(ReaProject* proj, MediaTrack* track, int note, int chan);

REAPERAPI_DECL int (*GetTrackNumMediaItems)(MediaTrack* tr);

// returns number of sends/receives/hardware outputs - category is <0 for receives, 0=sends, >0 for hardware outputs
REAPERAPI_DECL int (*GetTrackNumSends)(MediaTrack* tr, int category);

REAPERAPI_DECL bool (*GetTrackReceiveName)(MediaTrack* track, int recv_index, char* buf, int buflen);

REAPERAPI_DECL bool (*GetTrackReceiveUIMute)(MediaTrack* track, int recv_index, bool* mute);

REAPERAPI_DECL bool (*GetTrackReceiveUIVolPan)(MediaTrack* track, int recv_index, double* volume, double* pan);

REAPERAPI_DECL bool (*GetTrackSendName)(MediaTrack* track, int send_index, char* buf, int buflen);

REAPERAPI_DECL bool (*GetTrackSendUIMute)(MediaTrack* track, int send_index, bool* mute);

REAPERAPI_DECL bool (*GetTrackSendUIVolPan)(MediaTrack* track, int send_index, double* volume, double* pan);

// Gets track state, returns track name.
// flags will be set to:
// &1=folder
// &2=selected
// &4=has fx enabled
// &8=muted
// &16=soloed
// &32=SIP'd (with &16)
// &64=rec armed
REAPERAPI_DECL const char* (*GetTrackState)(MediaTrack* track, int* flags);

REAPERAPI_DECL bool (*GetTrackUIMute)(MediaTrack* track, bool* mute);

REAPERAPI_DECL bool (*GetTrackUIPan)(MediaTrack* track, double* pan1, double* pan2, int* panmode);

REAPERAPI_DECL bool (*GetTrackUIVolPan)(MediaTrack* track, double* volume, double* pan);

// returns true if the user selected a valid file, false if the user canceled the dialog
REAPERAPI_DECL bool (*GetUserFileNameForRead)(char* filename, const char* title, const char* defext);

// Get values from the user.
// If a caption begins with *, for example "*password", the edit field will not display the input text.
// Values are returned as a comma-separated string. Returns false if the user canceled the dialog.
REAPERAPI_DECL bool (*GetUserInputs)(const char* title, int num_inputs, const char* captions_csv, char* retvals_csv, int max_retval_len);

// Runs the system color chooser dialog.  Returns 0 if the user cancels the dialog.
REAPERAPI_DECL int (*GR_SelectColor)(HWND hwnd, int* color);

// this is just like win32 GetSysColor() but can have overrides.
REAPERAPI_DECL int (*GSC_mainwnd)(int t);

// dest should be at least 64 chars long to be safe
REAPERAPI_DECL void (*guidToString)(GUID* g, char* dest);

// Returns true if there exists an extended state value for a specific section and key. See SetExtState, GetExtState, DeleteExtState.
REAPERAPI_DECL bool (*HasExtState)(const char* section, const char* key);

// returns name of track plugin that is supplying MIDI programs,or NULL if there is none
REAPERAPI_DECL const char* (*HasTrackMIDIPrograms)(int track);

// returns name of track plugin that is supplying MIDI programs,or NULL if there is none
REAPERAPI_DECL const char* (*HasTrackMIDIProgramsEx)(ReaProject* proj, MediaTrack* track);

REAPERAPI_DECL void (*Help_Set)(const char* helpstring, bool is_temporary_help);

REAPERAPI_DECL void (*HiresPeaksFromSource)(PCM_source* src, PCM_source_peaktransfer_t* block);

// mode: 0=add to current track, 1=add new track, 3=add to selected items as takes, &4=stretch/loop to fit time sel, &8=try to match tempo 1x, &16=try to match tempo 0.5x, &32=try to match tempo 2x
REAPERAPI_DECL int (*InsertMedia)(char* file, int mode);

REAPERAPI_DECL int (*InsertMediaSection)(char* file, int mode, double startpct, double endpct, double pitchshift);

// inserts a track at idx,of course this will be clamped to 0..GetNumTracks(). wantDefaults=TRUE for default envelopes/FX,otherwise no enabled fx/env
REAPERAPI_DECL void (*InsertTrackAtIndex)(int idx, bool wantDefaults);

// are we in a realtime audio thread (between OnAudioBuffer calls,not in some worker/anticipative FX thread)? threadsafe
REAPERAPI_DECL int (*IsInRealTimeAudio)();

// get whether a take will be played (active take, unmuted, etc)
REAPERAPI_DECL bool (*IsItemTakeActiveForPlayback)(MediaItem* item, MediaItem_Take* take);

REAPERAPI_DECL bool (*IsMediaExtension)(const char* ext, bool wantOthers);

REAPERAPI_DECL bool (*IsMediaItemSelected)(MediaItem* item);

REAPERAPI_DECL bool (*IsTrackSelected)(MediaTrack* track);

// If mixer==true, returs true if the track is visible in the mixer.  If mixer==false, returns true if the track is visible in the track control panel.
REAPERAPI_DECL bool (*IsTrackVisible)(MediaTrack* track, bool mixer);

REAPERAPI_DECL int (*kbd_enumerateActions)(KbdSectionInfo* section, int idx, const char** nameOut);

REAPERAPI_DECL void (*kbd_formatKeyName)(ACCEL* ac, char* s);

REAPERAPI_DECL void (*kbd_getCommandName)(int cmd, char* s, KbdSectionInfo* section);

REAPERAPI_DECL const char* (*kbd_getTextFromCmd)(DWORD cmd, KbdSectionInfo* section);

// val/valhw are used for midi stuff.
// val=[0..127] and valhw=-1 (midi CC),
// valhw >=0 (midi pitch (valhw | val<<7)),
// relmode absolute (0) or 1/2/3 for relative adjust modes
REAPERAPI_DECL int (*KBD_OnMainActionEx)(int cmd, int val, int valhw, int relmode, HWND hwnd, ReaProject* proj);

// can be called from anywhere (threadsafe)
REAPERAPI_DECL void (*kbd_OnMidiEvent)(MIDI_event_t* evt, int dev_index);

// can be called from anywhere (threadsafe)
REAPERAPI_DECL void (*kbd_OnMidiList)(MIDI_eventlist* list, int dev_index);

REAPERAPI_DECL void (*kbd_ProcessActionsMenu)(HMENU menu, KbdSectionInfo* section);

REAPERAPI_DECL bool (*kbd_processMidiEventActionEx)(MIDI_event_t* evt, KbdSectionInfo* section, HWND hwndCtx);

REAPERAPI_DECL void (*kbd_reprocessMenu)(HMENU menu, KbdSectionInfo* section);

// actioncommandID may get modified
REAPERAPI_DECL bool (*kbd_RunCommandThroughHooks)(KbdSectionInfo* section, int* actionCommandID, int* val, int* valhw, int* relmode, HWND hwnd);

// time formatting mode overrides: -1=proj default.
// 0=time
// 1=measures.beats + time
// 2=measures.beats
// 3=seconds
// 4=samples
// 5=h:m:s:f
REAPERAPI_DECL int (*kbd_translateAccelerator)(HWND hwnd, MSG* msg, KbdSectionInfo* section);

REAPERAPI_DECL bool (*kbd_translateMouse)(void* winmsg, unsigned char* midimsg);

REAPERAPI_DECL void (*LICE__Destroy)(LICE_IBitmap* bm);

REAPERAPI_DECL void (*LICE__DestroyFont)(LICE_IFont* font);

REAPERAPI_DECL int (*LICE__DrawText)(LICE_IFont* font, LICE_IBitmap* bm, const char* str, int strcnt, RECT* rect, UINT dtFlags);

REAPERAPI_DECL void* (*LICE__GetBits)(LICE_IBitmap* bm);

REAPERAPI_DECL HDC (*LICE__GetDC)(LICE_IBitmap* bm);

REAPERAPI_DECL int (*LICE__GetHeight)(LICE_IBitmap* bm);

REAPERAPI_DECL int (*LICE__GetRowSpan)(LICE_IBitmap* bm);

REAPERAPI_DECL int (*LICE__GetWidth)(LICE_IBitmap* bm);

REAPERAPI_DECL bool (*LICE__IsFlipped)(LICE_IBitmap* bm);

REAPERAPI_DECL bool (*LICE__resize)(LICE_IBitmap* bm, int w, int h);

REAPERAPI_DECL LICE_pixel (*LICE__SetBkColor)(LICE_IFont* font, LICE_pixel color);

// font must REMAIN valid,unless LICE_FONT_FLAG_PRECALCALL is set
REAPERAPI_DECL void (*LICE__SetFromHFont)(LICE_IFont* font, HFONT hfont, int flags);

REAPERAPI_DECL LICE_pixel (*LICE__SetTextColor)(LICE_IFont* font, LICE_pixel color);

REAPERAPI_DECL void (*LICE__SetTextCombineMode)(LICE_IFont* ifont, int mode, float alpha);

REAPERAPI_DECL void (*LICE_Arc)(LICE_IBitmap* dest, float cx, float cy, float r, float minAngle, float maxAngle, LICE_pixel color, float alpha, int mode, bool aa);

REAPERAPI_DECL void (*LICE_Blit)(LICE_IBitmap* dest, LICE_IBitmap* src, int dstx, int dsty, int srcx, int srcy, int srcw, int srch, float alpha, int mode);

REAPERAPI_DECL void (*LICE_Blur)(LICE_IBitmap* dest, LICE_IBitmap* src, int dstx, int dsty, int srcx, int srcy, int srcw, int srch);

REAPERAPI_DECL void (*LICE_BorderedRect)(LICE_IBitmap* dest, int x, int y, int w, int h, LICE_pixel bgcolor, LICE_pixel fgcolor, float alpha, int mode);

REAPERAPI_DECL void (*LICE_Circle)(LICE_IBitmap* dest, float cx, float cy, float r, LICE_pixel color, float alpha, int mode, bool aa);

REAPERAPI_DECL void (*LICE_Clear)(LICE_IBitmap* dest, LICE_pixel color);

REAPERAPI_DECL void (*LICE_ClearRect)(LICE_IBitmap* dest, int x, int y, int w, int h, LICE_pixel mask, LICE_pixel orbits);

// Returns false if the line is entirely offscreen.
REAPERAPI_DECL bool (*LICE_ClipLine)(int* pX1, int* pY1, int* pX2, int* pY2, int xLo, int yLo, int xHi, int yHi);

REAPERAPI_DECL void (*LICE_Copy)(LICE_IBitmap* dest, LICE_IBitmap* src);

// create a new bitmap. this is like calling new LICE_MemBitmap (mode=0) or new LICE_SysBitmap (mode=1).
REAPERAPI_DECL LICE_IBitmap* (*LICE_CreateBitmap)(int mode, int w, int h);

REAPERAPI_DECL LICE_IFont* (*LICE_CreateFont)();

REAPERAPI_DECL void (*LICE_DrawChar)(LICE_IBitmap* bm, int x, int y, char c, LICE_pixel color, float alpha, int mode);

REAPERAPI_DECL void (*LICE_DrawGlyph)(LICE_IBitmap* dest, int x, int y, LICE_pixel color, LICE_pixel_chan* alphas, int glyph_w, int glyph_h, float alpha, int mode);

REAPERAPI_DECL void (*LICE_DrawRect)(LICE_IBitmap* dest, int x, int y, int w, int h, LICE_pixel color, float alpha, int mode);

REAPERAPI_DECL void (*LICE_DrawText)(LICE_IBitmap* bm, int x, int y, const char* string, LICE_pixel color, float alpha, int mode);

REAPERAPI_DECL void (*LICE_FillCircle)(LICE_IBitmap* dest, float cx, float cy, float r, LICE_pixel color, float alpha, int mode, bool aa);

REAPERAPI_DECL void (*LICE_FillConvexPolygon)(LICE_IBitmap* dest, int* x, int* y, int npoints, LICE_pixel color, float alpha, int mode);

REAPERAPI_DECL void (*LICE_FillRect)(LICE_IBitmap* dest, int x, int y, int w, int h, LICE_pixel color, float alpha, int mode);

REAPERAPI_DECL void (*LICE_FillTrapezoid)(LICE_IBitmap* dest, int x1a, int x1b, int y1, int x2a, int x2b, int y2, LICE_pixel color, float alpha, int mode);

REAPERAPI_DECL void (*LICE_FillTriangle)(LICE_IBitmap* dest, int x1, int y1, int x2, int y2, int x3, int y3, LICE_pixel color, float alpha, int mode);

REAPERAPI_DECL LICE_pixel (*LICE_GetPixel)(LICE_IBitmap* bm, int x, int y);

REAPERAPI_DECL void (*LICE_GradRect)(LICE_IBitmap* dest, int dstx, int dsty, int dstw, int dsth, float ir, float ig, float ib, float ia, float drdx, float dgdx, float dbdx, float dadx, float drdy, float dgdy, float dbdy, float dady, int mode);

REAPERAPI_DECL void (*LICE_Line)(LICE_IBitmap* dest, int x1, int y1, int x2, int y2, LICE_pixel color, float alpha, int mode, bool aa);

REAPERAPI_DECL void (*LICE_LineInt)(LICE_IBitmap* dest, int x1, int y1, int x2, int y2, LICE_pixel color, float alpha, int mode, bool aa);

REAPERAPI_DECL LICE_IBitmap* (*LICE_LoadPNG)(const char* filename, LICE_IBitmap* bmp);

REAPERAPI_DECL LICE_IBitmap* (*LICE_LoadPNGFromResource)(HINSTANCE hInst, int resid, LICE_IBitmap* bmp);

REAPERAPI_DECL void (*LICE_MeasureText)(const char* string, int* w, int* h);

REAPERAPI_DECL void (*LICE_MultiplyAddRect)(LICE_IBitmap* dest, int x, int y, int w, int h, float rsc, float gsc, float bsc, float asc, float radd, float gadd, float badd, float aadd);

REAPERAPI_DECL void (*LICE_PutPixel)(LICE_IBitmap* bm, int x, int y, LICE_pixel color, float alpha, int mode);

// these coordinates are offset from the center of the image,in source pixel coordinates
REAPERAPI_DECL void (*LICE_RotatedBlit)(LICE_IBitmap* dest, LICE_IBitmap* src, int dstx, int dsty, int dstw, int dsth, float srcx, float srcy, float srcw, float srch, float angle, bool cliptosourcerect, float alpha, int mode, float rotxcent, float rotycent);

REAPERAPI_DECL void (*LICE_RoundRect)(LICE_IBitmap* drawbm, float xpos, float ypos, float w, float h, int cornerradius, LICE_pixel col, float alpha, int mode, bool aa);

REAPERAPI_DECL void (*LICE_ScaledBlit)(LICE_IBitmap* dest, LICE_IBitmap* src, int dstx, int dsty, int dstw, int dsth, float srcx, float srcy, float srcw, float srch, float alpha, int mode);

REAPERAPI_DECL void (*LICE_SimpleFill)(LICE_IBitmap* dest, int x, int y, LICE_pixel newcolor, LICE_pixel comparemask, LICE_pixel keepmask);

// Move the loop selection left or right. Returns true if snap is enabled.
REAPERAPI_DECL bool (*Loop_OnArrow)(ReaProject* project, int direction);

REAPERAPI_DECL void (*Main_OnCommand)(int command, int flag);

REAPERAPI_DECL void (*Main_OnCommandEx)(int command, int flag, ReaProject* proj);

// opens a project. will prompt the user to save, etc.
// if you pass a .RTrackTemplate file then it adds that to the project instead.
REAPERAPI_DECL void (*Main_openProject)(char* name);

REAPERAPI_DECL void (*Main_UpdateLoopInfo)(int ignoremask);

// marks project as dirty (needing save)
REAPERAPI_DECL void (*MarkProjectDirty)(ReaProject* proj);

// If track is supplied, item is ignored
REAPERAPI_DECL void (*MarkTrackItemsDirty)(MediaTrack* track, MediaItem* item);

REAPERAPI_DECL double (*Master_GetPlayRate)(ReaProject* project);

REAPERAPI_DECL double (*Master_GetPlayRateAtTime)(double time_s, ReaProject* proj);

REAPERAPI_DECL double (*Master_GetTempo)();

// Convert play rate to/from a value between 0 and 1, representing the position on the project playrate slider.
REAPERAPI_DECL double (*Master_NormalizePlayRate)(double playrate, bool isnormalized);

// Convert the tempo to/from a value between 0 and 1, representing bpm in the range of 40-296 bpm.
REAPERAPI_DECL double (*Master_NormalizeTempo)(double bpm, bool isnormalized);

// type 0=OK,2=OKCANCEL,2=ABORTRETRYIGNORE,3=YESNOCANCEL,4=YESNO,5=RETRYCANCEL : ret 1=OK,2=CANCEL,3=ABORT,4=RETRY,5=IGNORE,6=YES,7=NO
REAPERAPI_DECL int (*MB)(const char* msg, const char* title, int type);

// Returns 1 if the track holds the item, 2 if the track is a folder containing the track that holds the item, etc.
REAPERAPI_DECL int (*MediaItemDescendsFromTrack)(MediaItem* item, MediaTrack* track);

// Create a MIDI_eventlist object. The returned object must be deleted with MIDI_eventlist_destroy().
REAPERAPI_DECL MIDI_eventlist* (*MIDI_eventlist_Create)();

// Destroy a MIDI_eventlist object that was created using MIDI_eventlist_Create().
REAPERAPI_DECL void (*MIDI_eventlist_Destroy)(MIDI_eventlist* evtlist);

// Reset all MIDI devices
REAPERAPI_DECL void (*midi_reinit)();

// get a pointer to the focused MIDI editor window
// see MIDIEditor_GetMode, MIDIEditor_OnCommand
REAPERAPI_DECL void* (*MIDIEditor_GetActive)();

// get the mode of a MIDI editor (0=piano roll, 1=event list, -1=invalid editor)
// see MIDIEditor_GetActive, MIDIEditor_OnCommand
REAPERAPI_DECL int (*MIDIEditor_GetMode)(void* midieditor);

// get the take that is currently being edited in this MIDI editor
REAPERAPI_DECL MediaItem_Take* (*MIDIEditor_GetTake)(void* midieditor);

// Send an action command to the last focused MIDI editor. Returns false if there is no MIDI editor open, or if the view mode (piano roll or event list) does not match the input.
// see MIDIEditor_OnCommand
REAPERAPI_DECL bool (*MIDIEditor_LastFocused_OnCommand)(int command_id, bool islistviewcommand);

// Send an action command to a MIDI editor. Returns false if the supplied MIDI editor pointer is not valid (not an open MIDI editor).
// see MIDIEditor_GetActive, MIDIEditor_LastFocused_OnCommand
REAPERAPI_DECL bool (*MIDIEditor_OnCommand)(void* midieditor, int command_id);

REAPERAPI_DECL void (*mkpanstr)(char* str, double pan);

REAPERAPI_DECL void (*mkvolpanstr)(char* str, double vol, double pan);

REAPERAPI_DECL void (*mkvolstr)(char* str, double vol);

REAPERAPI_DECL void (*MoveEditCursor)(double adjamt, bool dosel);

// returns TRUE if move succeeded
REAPERAPI_DECL bool (*MoveMediaItemToTrack)(MediaItem* item, MediaTrack* desttr);

REAPERAPI_DECL void (*MuteAllTracks)(bool mute);

REAPERAPI_DECL void (*my_getViewport)(RECT* r, RECT* sr, bool wantWort);

// get the command ID number for named command that was registered by an extension (such as "_SWS_ABOUT", etc)
REAPERAPI_DECL int (*NamedCommandLookup)(const char* command_name);

// direct way to simulate pause button hit
REAPERAPI_DECL void (*OnPauseButton)();

// direct way to simulate pause button hit
REAPERAPI_DECL void (*OnPauseButtonEx)(ReaProject* proj);

// direct way to simulate play button hit
REAPERAPI_DECL void (*OnPlayButton)();

// direct way to simulate play button hit
REAPERAPI_DECL void (*OnPlayButtonEx)(ReaProject* proj);

// direct way to simulate stop button hit
REAPERAPI_DECL void (*OnStopButton)();

// direct way to simulate stop button hit
REAPERAPI_DECL void (*OnStopButtonEx)(ReaProject* proj);

// Send an OSC message directly to REAPER. The value argument may be NULL. The message will be matched against the default OSC patterns. Only supported if control surface support was enabled when installing REAPER.
REAPERAPI_DECL void (*OscLocalMessageToHost)(const char* message, double* value);

// time formatting mode overrides: -1=proj default.
// 0=time
// 1=measures.beats + time
// 2=measures.beats
// 3=seconds
// 4=samples
// 5=h:m:s:f
REAPERAPI_DECL double (*parse_timestr)(const char* buf);

// time formatting mode overrides: -1=proj default.
// 0=time
// 1=measures.beats + time
// 2=measures.beats
// 3=seconds
// 4=samples
// 5=h:m:s:f
REAPERAPI_DECL double (*parse_timestr_len)(const char* buf, double offset, int modeoverride);

// parses time string,modeoverride see above
REAPERAPI_DECL double (*parse_timestr_pos)(const char* buf, int modeoverride);

REAPERAPI_DECL double (*parsepanstr)(char* str);

REAPERAPI_DECL PCM_sink* (*PCM_Sink_Create)(const char* filename, const char* cfg, int cfgl, int nch, int srate, bool buildpeaks);

REAPERAPI_DECL PCM_sink* (*PCM_Sink_CreateEx)(ReaProject* proj, const char* filename, const char* cfg, int cfgl, int nch, int srate, bool buildpeaks);

REAPERAPI_DECL PCM_sink* (*PCM_Sink_CreateMIDIFile)(const char* filename, const char* cfg, int cfgl, double bpm, int div);

REAPERAPI_DECL PCM_sink* (*PCM_Sink_CreateMIDIFileEx)(ReaProject* proj, const char* filename, const char* cfg, int cfgl, double bpm, int div);

REAPERAPI_DECL unsigned int (*PCM_Sink_Enum)(int id, const char** descstr);

REAPERAPI_DECL const char* (*PCM_Sink_GetExtension)(const void* data, int data_size);

REAPERAPI_DECL HWND (*PCM_Sink_ShowConfig)(const void* cfg, int cfg_l, HWND hwndParent);

REAPERAPI_DECL PCM_source* (*PCM_Source_CreateFromFile)(const char* filename);

REAPERAPI_DECL PCM_source* (*PCM_Source_CreateFromFileEx)(const char* filename, bool forcenoMidiImp);

// Creates a PCM_source from a ISimpleMediaDecoder
// (if fn is non-null, it will open the file in dec)
REAPERAPI_DECL PCM_source* (*PCM_Source_CreateFromSimple)(ISimpleMediaDecoder* dec, const char* fn);

REAPERAPI_DECL PCM_source* (*PCM_Source_CreateFromType)(const char* sourcetype);

// If a section/reverse block, retrieves offset/len/reverse. return true if success
REAPERAPI_DECL bool (*PCM_Source_GetSectionInfo)(PCM_source* src, double* offs, double* len, bool* rev);

REAPERAPI_DECL REAPER_PeakBuild_Interface* (*PeakBuild_Create)(PCM_source* src, const char* fn, int srate, int nch);

REAPERAPI_DECL REAPER_PeakGet_Interface* (*PeakGet_Create)(const char* fn, int srate, int nch);

// return nonzero on success
REAPERAPI_DECL int (*PlayPreview)(preview_register_t* preview);

// return nonzero on success
REAPERAPI_DECL int (*PlayPreviewEx)(preview_register_t* preview, int bufflags, double MSI);

// return nonzero on success,in these,m_out_chan is a track index (0-n)
REAPERAPI_DECL int (*PlayTrackPreview)(preview_register_t* preview);

// return nonzero on success,in these,m_out_chan is a track index (0-n)
REAPERAPI_DECL int (*PlayTrackPreview2)(ReaProject* proj, preview_register_t* preview);

// return nonzero on success,in these,m_out_chan is a track index (0-n)
REAPERAPI_DECL int (*PlayTrackPreview2Ex)(ReaProject* proj, preview_register_t* preview, int flags, double msi);

REAPERAPI_DECL void* (*plugin_getapi)(const char* name);

REAPERAPI_DECL char* (*plugin_getFilterList)();

REAPERAPI_DECL char* (*plugin_getImportableProjectFilterList)();

// like rec->Register
// 
// if you have a function called myfunction(..) that you want to expose to other extensions or plug-ins,
// use register("API_myfunction",funcaddress), and "-API_myfunction" to remove.
// Other extensions then use GetFunc("myfunction") to get the function pointer.
// REAPER will also export the function address to ReaScript, so your extension could supply
// a Python module that provides a wrapper called RPR_myfunction(..).
// register("APIdef_myfunction",defstring) will include your function declaration and help
// in the auto-generated REAPER API header and ReaScript documentation.
// defstring is four null-separated fields: return type, argument types, argument names, and help.
// Example: double myfunction(char* str, int flag) would have
// defstring="double\0char*,int\0str,flag\0help text for myfunction"
// 
// another thing you can register is "hookcommand", which you pass a function:
//  NON_API: bool runCommand(int command, int flag);
//           register("hookcommand",runCommand);
// which returns TRUE to eat (process) the command.
// flag is usually 0 but can sometimes have useful info depending on the message.
// note: it's OK to call Main_OnCommand() within your runCommand, however you MUST check for recursion if doing so!
// in fact, any use of this hook should benefit from a simple reentrancy test...
// 
// you can also register command IDs for main window actions,
// register with "command_id", parameter is a unique string with only A-Z, 0-9,
// returns command ID for main actions (or 0 if not supported/out of actions)
// 
// register("command_id_lookup", unique_string) will look up the integer ID of the named action
// without registering the string if it doesn't already exist.
REAPERAPI_DECL int (*plugin_register)(const char* name, void* infostruct);

REAPERAPI_DECL void (*PluginWantsAlwaysRunFx)(int amt);

// adds prevent_count to the UI refresh prevention state; always add then remove the same amount, or major disfunction will occur
REAPERAPI_DECL void (*PreventUIRefresh)(int prevent_count);

REAPERAPI_DECL void* (*projectconfig_var_addr)(ReaProject* proj, int idx);

// returns offset to pass to projectconfig_var_addr() to get project-config var of name. szout gets size of object.
REAPERAPI_DECL int (*projectconfig_var_getoffs)(const char* name, int* szout);

// version must be REAPER_PITCHSHIFT_API_VER
REAPERAPI_DECL IReaperPitchShift* (*ReaperGetPitchShiftAPI)(int version);

// Causes REAPER to display the error message after the current ReaScript finishes.
REAPERAPI_DECL void (*ReaScriptError)(const char* errmsg);

REAPERAPI_DECL int (*RecursiveCreateDirectory)(const char* path, void* unused);

// refresh the toolbar button state of a toggle action
REAPERAPI_DECL void (*RefreshToolbar)(int command_id);

REAPERAPI_DECL void (*relative_fn)(const char* in, char* out, int outlen);

REAPERAPI_DECL bool (*RenderFileSection)(const char* source_filename, const char* target_filename, double start_percent, double end_percent, double playrate);

REAPERAPI_DECL const char* (*Resample_EnumModes)(int mode);

REAPERAPI_DECL REAPER_Resample_Interface* (*Resampler_Create)();

REAPERAPI_DECL void (*resolve_fn)(const char* in, char* out, int outlen);

REAPERAPI_DECL void (*screenset_register)(char* id, void* callbackFunc, void* param);

REAPERAPI_DECL void (*screenset_registerNew)(char* id, screensetNewCallbackFunc callbackFunc, void* param);

REAPERAPI_DECL void (*screenset_unregister)(char* id);

REAPERAPI_DECL void (*screenset_unregisterByParam)(void* param);

REAPERAPI_DECL KbdSectionInfo* (*SectionFromUniqueID)(int uniqueID);

REAPERAPI_DECL void (*SelectAllMediaItems)(ReaProject* proj, bool selected);

REAPERAPI_DECL void (*SelectProjectInstance)(ReaProject* proj);

// Send an OSC message to REAPER. See CreateLocalOscHandler, DestroyLocalOscHandler.
REAPERAPI_DECL void (*SendLocalOscMessage)(void* local_osc_handler, const char* msg, int msglen);

// set this take active in this media item
REAPERAPI_DECL void (*SetActiveTake)(MediaItem_Take* take);

// sets all or selected tracks to mode.
REAPERAPI_DECL void (*SetAutomationMode)(int mode, bool onlySel);

// set current BPM in project, set wantUndo=true to add undo point
REAPERAPI_DECL void (*SetCurrentBPM)(ReaProject* __proj, double bpm, bool wantUndo);

REAPERAPI_DECL void (*SetEditCurPos)(double time, bool moveview, bool seekplay);

REAPERAPI_DECL void (*SetEditCurPos2)(ReaProject* proj, double time, bool moveview, bool seekplay);

// Set the extended state value for a specific section and key. persist=true means the value should be stored and reloaded the next time REAPER is opened. See GetExtState, DeleteExtState, HasExtState.
REAPERAPI_DECL void (*SetExtState)(const char* section, const char* key, const char* value, bool persist);

// set &1 to show the master track in the TCP, &2 to show in the mixer. Returns the previous visibility state. See GetMasterTrackVisibility.
REAPERAPI_DECL int (*SetMasterTrackVisibility)(int flag);

// Set media item numerical-value attributes.
// B_MUTE : bool * to muted state
// B_LOOPSRC : bool * to loop source
// B_ALLTAKESPLAY : bool * to all takes play
// B_UISEL : bool * to ui selected
// C_BEATATTACHMODE : char * to one char of beat attached mode, -1=def, 0=time, 1=allbeats, 2=beatsosonly
// C_LOCK : char * to one char of lock flags (&1 is locked, currently)
// D_VOL : double * of item volume (volume bar)
// D_POSITION : double * of item position (seconds)
// D_LENGTH : double * of item length (seconds)
// D_SNAPOFFSET : double * of item snap offset (seconds)
// D_FADEINLEN : double * of item fade in length (manual, seconds)
// D_FADEOUTLEN : double * of item fade out length (manual, seconds)
// D_FADEINLEN_AUTO : double * of item autofade in length (seconds, -1 for no autofade set)
// D_FADEOUTLEN_AUTO : double * of item autofade out length (seconds, -1 for no autofade set)
// C_FADEINSHAPE : int * to fadein shape, 0=linear, ...
// C_FADEOUTSHAPE : int * to fadeout shape
// I_GROUPID : int * to group ID (0 = no group)
// I_LASTY : int * to last y position in track (readonly)
// I_LASTH : int * to last height in track (readonly)
// I_CUSTOMCOLOR : int * : custom color, windows standard color order (i.e. RGB(r,g,b)|0x100000). if you do not |0x100000, then it will not be used (though will store the color anyway)
// I_CURTAKE : int * to active take
// IP_ITEMNUMBER : int, item number within the track (read-only, returns the item number directly)F_FREEMODE_Y : float * to free mode y position (0..1)
// F_FREEMODE_H : float * to free mode height (0..1)
REAPERAPI_DECL bool (*SetMediaItemInfo_Value)(MediaItem* item, const char* parmname, double newvalue);

// Redraws the screen only if refreshUI == true.
// See UpdateArrange().
REAPERAPI_DECL bool (*SetMediaItemLength)(MediaItem* item, double length, bool refreshUI);

// Redraws the screen only if refreshUI == true.
// See UpdateArrange().
REAPERAPI_DECL bool (*SetMediaItemPosition)(MediaItem* item, double position, bool refreshUI);

REAPERAPI_DECL void (*SetMediaItemSelected)(MediaItem* item, bool selected);

// Set media item take numerical-value attributes.
// D_STARTOFFS : double *, start offset in take of item
// D_VOL : double *, take volume
// D_PAN : double *, take pan
// D_PANLAW : double *, take pan law (-1.0=default, 0.5=-6dB, 1.0=+0dB, etc)
// D_PLAYRATE : double *, take playrate (1.0=normal, 2.0=doublespeed, etc)
// D_PITCH : double *, take pitch adjust (in semitones, 0.0=normal, +12 = one octave up, etc)
// B_PPITCH, bool *, preserve pitch when changing rate
// I_CHANMODE, int *, channel mode (0=normal, 1=revstereo, 2=downmix, 3=l, 4=r)
// I_PITCHMODE, int *, pitch shifter mode, -1=proj default, otherwise high word=shifter low word = parameter
// I_CUSTOMCOLOR : int *, custom color, windows standard color order (i.e. RGB(r,g,b)|0x100000). if you do not |0x100000, then it will not be used (though will store the color anyway)
// IP_TAKENUMBER : int, take number within the item (read-only, returns the take number directly)
REAPERAPI_DECL bool (*SetMediaItemTakeInfo_Value)(MediaItem_Take* take, const char* parmname, double newvalue);

// Set track numerical-value attributes.
// B_MUTE : bool * : mute flag
// B_PHASE : bool * : invert track phase
// IP_TRACKNUMBER : int : track number (returns zero if not found, -1 for master track) (read-only, returns the int directly)
// I_SOLO : int * : 0=not soloed, 1=solo, 2=soloed in place
// I_FXEN : int * : 0=fx bypassed, nonzero = fx active
// I_RECARM : int * : 0=not record armed, 1=record armed
// I_RECINPUT : int * : record input. <0 = no input, 0..n = mono hardware input, 512+n = rearoute input, 1024 set for stereo input pair. 4096 set for MIDI input, if set, then low 5 bits represent channel (0=all, 1-16=only chan), then next 5 bits represent physical input (31=all, 30=VKB)
// I_RECMODE : int * : record mode (0=input, 1=stereo out, 2=none, 3=stereo out w/latcomp, 4=midi output, 5=mono out, 6=mono out w/ lat comp, 7=midi overdub, 8=midi replace
// I_RECMON : int * : record monitor (0=off, 1=normal, 2=not when playing (tapestyle))
// I_RECMONITEMS : int * : monitor items while recording (0=off, 1=on)
// I_AUTOMODE : int * : track automation mode (0=trim/off, 1=read, 2=touch, 3=write, 4=latch
// I_NCHAN : int * : number of track channels, must be 2-64, even
// I_SELECTED : int * : track selected? 0 or 1
// I_WNDH : int * : current TCP window height (Read-only)
// I_FOLDERDEPTH : int * : folder depth change (0=normal, 1=track is a folder parent, -1=track is the last in the innermost folder, -2=track is the last in the innermost and next-innermost folders, etc
// I_FOLDERCOMPACT : int * : folder compacting (only valid on folders), 0=normal, 1=small, 2=tiny children
// I_MIDIHWOUT : int * : track midi hardware output index (<0 for disabled, low 5 bits are which channels (0=all, 1-16), next 5 bits are output device index (0-31))
// I_PERFFLAGS : int * : track perf flags (&1=no media buffering, &2=no anticipative FX)
// I_CUSTOMCOLOR : int * : custom color, windows standard color order (i.e. RGB(r,g,b)|0x100000). if you do not |0x100000, then it will not be used (though will store the color anyway)
// I_HEIGHTOVERRIDE : int * : custom height override for TCP window. 0 for none, otherwise size in pixels
// D_VOL : double * : trim volume of track (0 (-inf)..1 (+0dB) .. 2 (+6dB) etc ..)
// D_PAN : double * : trim pan of track (-1..1)
// D_WIDTH : double * : width of track (-1..1)
// D_DUALPANL : double * : dualpan position 1 (-1..1), only if I_PANMODE==6
// D_DUALPANR : double * : dualpan position 2 (-1..1), only if I_PANMODE==6
// I_PANMODE : int * : pan mode (0 = classic 3.x, 3=new balance, 5=stereo pan, 6 = dual pan)
// D_PANLAW : double * : pan law of track. <0 for project default, 1.0 for +0dB, etc
// P_ENV : read only, returns TrackEnvelope *, setNewValue=<VOLENV, <PANENV, etc
// B_SHOWINMIXER : bool * : show track panel in mixer -- do not use on master
// B_SHOWINTCP : bool * : show track panel in tcp -- do not use on master
// B_MAINSEND : bool * : track sends audio to parent
// B_FREEMODE : bool * : track free-mode enabled (requires UpdateTimeline() after changing etc)
// C_BEATATTACHMODE : char * : char * to one char of beat attached mode, -1=def, 0=time, 1=allbeats, 2=beatsposonly
// F_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0.0=smallest allowed, 1=max allowed)
// F_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the fx+send total area (0=min allow, 1=max)
REAPERAPI_DECL bool (*SetMediaTrackInfo_Value)(MediaTrack* tr, const char* parmname, double newvalue);

// Scroll the mixer so that leftmosttrack is the leftmost visible track. Returns the leftmost track after scrolling, which may be different from the passed-in track if there are not enough tracks to its right.
REAPERAPI_DECL MediaTrack* (*SetMixerScroll)(MediaTrack* leftmosttrack);

// Set the mouse modifier assignment for a specific modifier key assignment, in a specific context.
// Context is a string like "MM_CTX_ITEM". Find these strings by modifying an assignment in 
// Preferences/Editing/Mouse Modifiers, then looking in reaper-mouse.ini.
// Modifier flag is a number from 0 to 15: add 1 for shift, 2 for control, 4 for alt, 8 for win.
// (OSX: add 1 for shift, 2 for command, 4 for opt, 8 for control.)
// For left-click and double-click contexts, the action can be any built-in command ID number
// or any custom action ID string. Find built-in command IDs in the REAPER actions window
// (enable "show action IDs" in the context menu), and find custom action ID strings in reaper-kb.ini.
// For built-in mouse modifier behaviors, find action IDs (which will be low numbers)
// by modifying an assignment in Preferences/Editing/Mouse Modifiers, then looking in reaper-mouse.ini.
// Assigning an action of -1 will reset that mouse modifier behavior to factory default.
// See GetMouseModifier.
// 
REAPERAPI_DECL void (*SetMouseModifier)(const char* context, int modifier_flag, const char* action);

// Set exactly one track selected, deselect all others
REAPERAPI_DECL void (*SetOnlyTrackSelected)(MediaTrack* track);

REAPERAPI_DECL bool (*SetProjectMarker)(int markrgnindexnumber, bool isrgn, double pos, double rgnend, const char* name);

REAPERAPI_DECL bool (*SetProjectMarker2)(ReaProject* proj, int markrgnindexnumber, bool isrgn, double pos, double rgnend, const char* name);

// color should be 0 to not change, or RGB(x,y,z)|0x1000000 to set custom
REAPERAPI_DECL bool (*SetProjectMarker3)(ReaProject* proj, int markrgnindexnumber, bool isrgn, double pos, double rgnend, const char* name, int color);

// Add (addorremove > 0) or remove (addorremove < 0) a track from this region when using the region render matrix.
REAPERAPI_DECL void (*SetRegionRenderMatrix)(ReaProject* proj, int regionindex, MediaTrack* track, int addorremove);

// Used by pcmsink objects to set an error to display while creating the pcmsink object.
REAPERAPI_DECL void (*SetRenderLastError)(char* errorstr);

// Set parameters of a tempo/time signature marker. Provide either timepos (with measurepos=-1, beatpos=-1), or measurepos and beatpos (with timepos=-1). If timesig_num and timesig_denom are zero, the previous time signature will be used. ptidx=-1 will insert a new tempo/time signature marker. See CountTempoTimeSigMarkers, GetTempoTimeSigMarker, AddTempoTimeSigMarker.
REAPERAPI_DECL bool (*SetTempoTimeSigMarker)(ReaProject* proj, int ptidx, double timepos, int measurepos, double beatpos, double bpm, int timesig_num, int timesig_denom, bool lineartempo);

REAPERAPI_DECL void (*SetTrackAutomationMode)(MediaTrack* tr, int mode);

// Set the track color, as 0x00RRGGBB.
REAPERAPI_DECL void (*SetTrackColor)(MediaTrack* track, int color);

REAPERAPI_DECL const char* (*SetTrackMIDINoteName)(int track, int note, int chan, const char* name);

REAPERAPI_DECL const char* (*SetTrackMIDINoteNameEx)(ReaProject* proj, MediaTrack* track, int note, int chan, const char* name);

REAPERAPI_DECL void (*SetTrackSelected)(MediaTrack* track, bool selected);

// send_idx<0 for receives, isend=1 for end of edit, -1 for an instant edit (such as reset), 0 for normal tweak.
REAPERAPI_DECL bool (*SetTrackSendUIPan)(MediaTrack* track, int send_idx, double pan, int isend);

// send_idx<0 for receives, isend=1 for end of edit, -1 for an instant edit (such as reset), 0 for normal tweak.
REAPERAPI_DECL bool (*SetTrackSendUIVol)(MediaTrack* track, int send_idx, double vol, int isend);

REAPERAPI_DECL void (*ShowActionList)(KbdSectionInfo* caller, HWND callerWnd);

// Show a message to the user (also useful for debugging). Send "\n" for newline, "" to clear the console window.
REAPERAPI_DECL void (*ShowConsoleMsg)(const char* msg);

// type 0=OK,2=OKCANCEL,2=ABORTRETRYIGNORE,3=YESNOCANCEL,4=YESNO,5=RETRYCANCEL : ret 1=OK,2=CANCEL,3=ABORT,4=RETRY,5=IGNORE,6=YES,7=NO
REAPERAPI_DECL int (*ShowMessageBox)(const char* msg, const char* title, int type);

REAPERAPI_DECL double (*SLIDER2DB)(double y);

REAPERAPI_DECL double (*SnapToGrid)(ReaProject* project, double time_pos);

// solo=2 for SIP
REAPERAPI_DECL void (*SoloAllTracks)(int solo);

// the original item becomes the left-hand split, the function returns the right-hand split (or NULL if the split failed)
REAPERAPI_DECL MediaItem* (*SplitMediaItem)(MediaItem* item, double position);

// return nonzero on success
REAPERAPI_DECL int (*StopPreview)(preview_register_t* preview);

// return nonzero on success
REAPERAPI_DECL int (*StopTrackPreview)(preview_register_t* preview);

// return nonzero on success
REAPERAPI_DECL int (*StopTrackPreview2)(void* proj, preview_register_t* preview);

REAPERAPI_DECL void (*stringToGuid)(const char* str, GUID* g);

// convert a beat position (or optionally a beats+measures if measures is non-NULL) to time.
REAPERAPI_DECL double (*TimeMap2_beatsToTime)(ReaProject* proj, double tpos, int* measures);

// get the effective BPM at the time (seconds) position (i.e. 2x in /8 signatures)
REAPERAPI_DECL double (*TimeMap2_GetDividedBpmAtTime)(ReaProject* proj, double time);

// when does the next time map (tempo or time sig) change occur
REAPERAPI_DECL double (*TimeMap2_GetNextChangeTime)(ReaProject* proj, double time);

// converts project QN position to time.
REAPERAPI_DECL double (*TimeMap2_QNToTime)(ReaProject* proj, double qn);

// convert a time into beats.
// if measures is non-NULL, measures will be set to the measure count, return value will be beats since measure.
// if cml is non-NULL, will be set to current measure length in beats (i.e. time signature numerator)
// if fullbeats is non-NULL, and measures is non-NULL, fullbeats will get the full beat count (same value returned if measures is NULL).
// if cdenom is non-NULL, will be set to the current time signature denominator.
REAPERAPI_DECL double (*TimeMap2_timeToBeats)(ReaProject* proj, double tpos, int* measures, int* cml, double* fullbeats, int* cdenom);

// converts project time position to QN position.
REAPERAPI_DECL double (*TimeMap2_timeToQN)(ReaProject* proj, double tpos);

// get the effective BPM at the time (seconds) position (i.e. 2x in /8 signatures)
REAPERAPI_DECL double (*TimeMap_GetDividedBpmAtTime)(double time);

// get the effective time signature and tempo
REAPERAPI_DECL void (*TimeMap_GetTimeSigAtTime)(ReaProject* proj, double time, int* timesig_num, int* timesig_denom, double* tempo);

// converts project QN position to time.
REAPERAPI_DECL double (*TimeMap_QNToTime)(double qn);

// converts project QN position to time.
REAPERAPI_DECL double (*TimeMap_timeToQN)(double qn);

// send_idx<0 for receives
REAPERAPI_DECL bool (*ToggleTrackSendUIMute)(MediaTrack* track, int send_idx);

REAPERAPI_DECL double (*Track_GetPeakHoldDB)(MediaTrack* track, int channel, bool clear);

REAPERAPI_DECL double (*Track_GetPeakInfo)(MediaTrack* track, int channel);

// displays tooltip at location, or removes if empty string
REAPERAPI_DECL void (*TrackCtl_SetToolTip)(const char* fmt, int xpos, int ypos, bool topmost);

REAPERAPI_DECL bool (*TrackFX_EndParamEdit)(MediaTrack* track, int fx, int param);

// Note: only works with FX that support Cockos VST extensions.
REAPERAPI_DECL bool (*TrackFX_FormatParamValue)(MediaTrack* track, int fx, int param, double val, char* buf, int buflen);

// Note: only works with FX that support Cockos VST extensions.
REAPERAPI_DECL bool (*TrackFX_FormatParamValueNormalized)(MediaTrack* track, int fx, int param, double value, char* buf, int buflen);

// Get the index of the first track FX insert that matches fxname. If the FX is not in the chain and instantiate is true, it will be inserted. See TrackFX_GetInstrument, TrackFX_GetEQ.
REAPERAPI_DECL int (*TrackFX_GetByName)(MediaTrack* track, const char* fxname, bool instantiate);

// returns index of effect visible in chain, or -1 for chain hidden, or -2 for chain visible but no effect selected
REAPERAPI_DECL int (*TrackFX_GetChainVisible)(MediaTrack* track);

REAPERAPI_DECL int (*TrackFX_GetCount)(MediaTrack* track);

// See TrackFX_SetEnabled
REAPERAPI_DECL bool (*TrackFX_GetEnabled)(MediaTrack* track, int fx);

// Get the index of ReaEQ in the track FX chain. If ReaEQ is not in the chain and instantiate is true, it will be inserted. See TrackFX_GetInstrument, TrackFX_GetByName.
REAPERAPI_DECL int (*TrackFX_GetEQ)(MediaTrack* track, bool instantiate);

// Returns true if the EQ band is enabled.
// Returns false if the band is disabled, or if track/fxidx is not ReaEQ.
// Bandtype: 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.
// Bandidx: 0=first band matching bandtype, 1=2nd band matching bandtype, etc.
// See TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_SetEQParam, TrackFX_SetEQBandEnabled.
REAPERAPI_DECL bool (*TrackFX_GetEQBandEnabled)(MediaTrack* track, int fxidx, int bandtype, int bandidx);

// Returns false if track/fxidx is not ReaEQ.
// Bandtype: -1=master gain, 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.
// Bandidx (ignored for master gain): 0=first band matching bandtype, 1=2nd band matching bandtype, etc.
// Paramtype (ignored for master gain): 0=freq, 1=gain, 2=Q.
// See TrackFX_GetEQ, TrackFX_SetEQParam, TrackFX_GetEQBandEnabled, TrackFX_SetEQBandEnabled.
REAPERAPI_DECL bool (*TrackFX_GetEQParam)(MediaTrack* track, int fxidx, int* bandtype, int* bandidx, int* paramtype, double* normval);

// returns HWND of floating window for effect index, if any
REAPERAPI_DECL HWND (*TrackFX_GetFloatingWindow)(MediaTrack* track, int index);

REAPERAPI_DECL bool (*TrackFX_GetFormattedParamValue)(MediaTrack* track, int fx, int param, char* buf, int buflen);

REAPERAPI_DECL GUID* (*TrackFX_GetFXGUID)(MediaTrack* track, int fx);

REAPERAPI_DECL bool (*TrackFX_GetFXName)(MediaTrack* track, int fx, char* buf, int buflen);

// Get the index of the first track FX insert that is a virtual instrument, or -1 if none. See TrackFX_GetEQ, TrackFX_GetByName.
REAPERAPI_DECL int (*TrackFX_GetInstrument)(MediaTrack* track);

REAPERAPI_DECL int (*TrackFX_GetNumParams)(MediaTrack* track, int fx);

// Returns true if this FX UI is open in the FX chain window or a floating window. See TrackFX_SetOpen
REAPERAPI_DECL bool (*TrackFX_GetOpen)(MediaTrack* track, int fx);

REAPERAPI_DECL double (*TrackFX_GetParam)(MediaTrack* track, int fx, int param, double* minval, double* maxval);

REAPERAPI_DECL bool (*TrackFX_GetParameterStepSizes)(MediaTrack* track, int fx, int param, double* step, double* smallstep, double* largestep, bool* istoggle);

REAPERAPI_DECL double (*TrackFX_GetParamEx)(MediaTrack* track, int fx, int param, double* minval, double* maxval, double* midval);

REAPERAPI_DECL bool (*TrackFX_GetParamName)(MediaTrack* track, int fx, int param, char* buf, int buflen);

REAPERAPI_DECL double (*TrackFX_GetParamNormalized)(MediaTrack* track, int fx, int param);

// Get the name of the preset currently showing in the REAPER dropdown. Returns false if the current FX parameters do not exactly match the factory preset (in other words, if the user loaded the preset but moved the knobs afterward. See TrackFX_SetPreset
REAPERAPI_DECL bool (*TrackFX_GetPreset)(MediaTrack* track, int fx, char* presetname, int maxlen);

// Returns current preset index, or -1 if error. numberOfPresetsOut will be set to total number of presets available. See TrackFX_SetPresetByIndex
REAPERAPI_DECL int (*TrackFX_GetPresetIndex)(MediaTrack* track, int fx, int* numberOfPresetsOut);

// presetmove==1 activates the next preset, presetmove==-1 activates the previous preset, etc.
REAPERAPI_DECL bool (*TrackFX_NavigatePresets)(MediaTrack* track, int fx, int presetmove);

// See TrackFX_GetEnabled
REAPERAPI_DECL void (*TrackFX_SetEnabled)(MediaTrack* track, int fx, bool enabled);

// Enable or disable a ReaEQ band.
// Returns false if track/fxidx is not ReaEQ.
// Bandtype: 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.
// Bandidx: 0=first band matching bandtype, 1=2nd band matching bandtype, etc.
// See TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_SetEQParam, TrackFX_GetEQBandEnabled.
REAPERAPI_DECL bool (*TrackFX_SetEQBandEnabled)(MediaTrack* track, int fxidx, int bandtype, int bandidx, bool enable);

// Returns false if track/fxidx is not ReaEQ. Targets a band matching bandtype.
// Bandtype: -1=master gain, 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.
// Bandidx (ignored for master gain): 0=target first band matching bandtype, 1=target 2nd band matching bandtype, etc.
// Paramtype (ignored for master gain): 0=freq, 1=gain, 2=Q.
// See TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_GetEQBandEnabled, TrackFX_SetEQBandEnabled.
REAPERAPI_DECL bool (*TrackFX_SetEQParam)(MediaTrack* track, int fxidx, int paramidx, int bandtype, int bandidx, int paramtype, double val, bool isnorm);

// Open this FX UI. See TrackFX_GetOpen
REAPERAPI_DECL void (*TrackFX_SetOpen)(MediaTrack* track, int fx, bool open);

REAPERAPI_DECL bool (*TrackFX_SetParam)(MediaTrack* track, int fx, int param, double val);

REAPERAPI_DECL bool (*TrackFX_SetParamNormalized)(MediaTrack* track, int fx, int param, double value);

// See TrackFX_GetPreset
REAPERAPI_DECL bool (*TrackFX_SetPreset)(MediaTrack* track, int fx, const char* presetname);

// Sets preset idx for fx fx. Returns true on success.See TrackFX_GetPresetIndex
REAPERAPI_DECL bool (*TrackFX_SetPresetByIndex)(MediaTrack* track, int fx, int idx);

// showflag=0 for hidechain, =1 for show chain(index valid), =2 for hide floating window(index valid), =3 for show floating window (index valid)
REAPERAPI_DECL void (*TrackFX_Show)(MediaTrack* track, int index, int showFlag);

REAPERAPI_DECL void (*TrackList_AdjustWindows)(bool isMajor);

REAPERAPI_DECL void (*TrackList_UpdateAllExternalSurfaces)();

// call to start a new block
REAPERAPI_DECL void (*Undo_BeginBlock)();

// call to start a new block
REAPERAPI_DECL void (*Undo_BeginBlock2)(void* proj);

// returns string of next action,if able,NULL if not
REAPERAPI_DECL const char* (*Undo_CanRedo2)(void* proj);

// returns string of last action,if able,NULL if not
REAPERAPI_DECL const char* (*Undo_CanUndo2)(void* proj);

// nonzero if success
REAPERAPI_DECL int (*Undo_DoRedo2)(void* proj);

// nonzero if success
REAPERAPI_DECL int (*Undo_DoUndo2)(void* proj);

// call to end the block,with extra flags if any,and a description
REAPERAPI_DECL void (*Undo_EndBlock)(const char* descchange, int extraflags);

// call to end the block,with extra flags if any,and a description
REAPERAPI_DECL void (*Undo_EndBlock2)(void* proj, const char* descchange, int extraflags);

// limited state change to items
REAPERAPI_DECL void (*Undo_OnStateChange)(const char* descchange);

// limited state change to items
REAPERAPI_DECL void (*Undo_OnStateChange2)(void* proj, const char* descchange);

REAPERAPI_DECL void (*Undo_OnStateChange_Item)(ReaProject* proj, const char* name, MediaItem* item);

// trackparm=-1 by default,or if updating one fx chain,you can specify track index
REAPERAPI_DECL void (*Undo_OnStateChangeEx)(const char* descchange, int whichStates, int trackparm);

// trackparm=-1 by default,or if updating one fx chain,you can specify track index
REAPERAPI_DECL void (*Undo_OnStateChangeEx2)(void* proj, const char* descchange, int whichStates, int trackparm);

// Redraw the arrange view
REAPERAPI_DECL void (*UpdateArrange)();

REAPERAPI_DECL void (*UpdateItemInProject)(MediaItem* item);

// Redraw the arrange view and ruler
REAPERAPI_DECL void (*UpdateTimeline)();

// returns true if the pointer is a valid object of the right type
REAPERAPI_DECL bool (*ValidatePtr)(void* pointer, const char* ctypename);

// Opens the prefs to a page, use pageByName if page is 0.
REAPERAPI_DECL void (*ViewPrefs)(int page, const char* pageByName);

REAPERAPI_DECL bool (*WDL_VirtualWnd_ScaledBlitBG)(LICE_IBitmap* dest, WDL_VirtualWnd_BGCfg* src, int destx, int desty, int destw, int desth, int clipx, int clipy, int clipw, int cliph, float alpha, int mode);

// [S&M] Instanciates a new "fast string". You must delete this string, see SNM_DeleteFastString.
REAPERAPI_DECL WDL_FastString* (*SNM_CreateFastString)(const char* str);

// [S&M] Deletes a "fast string" instance.
REAPERAPI_DECL void (*SNM_DeleteFastString)(WDL_FastString* str);

// [S&M] Gets the "fast string" content.
REAPERAPI_DECL const char* (*SNM_GetFastString)(WDL_FastString* str);

// [S&M] Gets the "fast string" length.
REAPERAPI_DECL int (*SNM_GetFastStringLength)(WDL_FastString* str);

// [S&M] Sets the "fast string" content. Returns str for facility.
REAPERAPI_DECL WDL_FastString* (*SNM_SetFastString)(WDL_FastString* str, const char* newstr);

// [S&M] Gets a take by GUID as string.
REAPERAPI_DECL MediaItem_Take* (*SNM_GetMediaItemTakeByGUID)(ReaProject* project, const char* guid);

// [S&M] Gets the source type of a take. Returns false if failed (e.g. take with empty source, etc..)
REAPERAPI_DECL bool (*SNM_GetSourceType)(MediaItem_Take* take, WDL_FastString* type);

// [S&M] Gets or sets a take source state. Returns false if failed. Use takeidx=-1 to get/alter the active take.
// Note: this function does not use a MediaItem_Take* param in order to manage empty takes (i.e. takes with MediaItem_Take*==NULL), see SNM_GetSetSourceState2.
REAPERAPI_DECL bool (*SNM_GetSetSourceState)(MediaItem* item, int takeidx, WDL_FastString* state, bool setnewvalue);

// [S&M] Gets or sets a take source state. Returns false if failed.
// Note: this function cannot deal with empty takes, see SNM_GetSetSourceState.
REAPERAPI_DECL bool (*SNM_GetSetSourceState2)(MediaItem_Take* take, WDL_FastString* state, bool setnewvalue);

// [S&M] Gets or sets the state of a track, an item or an envelope. The state chunk size is unlimited. Returns false if failed.
// When getting a track state (and when you are not interested in FX data), you can use wantminimalstate=true to radically reduce the length of the state. Do not set such minimal states back though, this is for read-only applications!
// Note: unlike the native GetSetObjectState, calling to FreeHeapPtr() is not required.
REAPERAPI_DECL bool (*SNM_GetSetObjectState)(void* obj, WDL_FastString* state, bool setnewvalue, bool wantminimalstate);

// [S&M] Adds a receive. Returns false if nothing updated.
// type -1=Default type (user preferences), 0=Post-Fader (Post-Pan), 1=Pre-FX, 2=deprecated, 3=Pre-Fader (Post-FX).
// Note: obeys default sends preferences, supports frozen tracks, etc..
REAPERAPI_DECL bool (*SNM_AddReceive)(MediaTrack* src, MediaTrack* dest, int type);

// [S&M] Removes a receive. Returns false if nothing updated.
REAPERAPI_DECL bool (*SNM_RemoveReceive)(MediaTrack* tr, int rcvidx);

// [S&M] Removes all receives from srctr. Returns false if nothing updated.
REAPERAPI_DECL bool (*SNM_RemoveReceivesFrom)(MediaTrack* tr, MediaTrack* srctr);

// [S&M] Returns an integer preference (look in project prefs first, then in general prefs). Returns errvalue if failed (e.g. varname not found).
REAPERAPI_DECL int (*SNM_GetIntConfigVar)(const char* varname, int errvalue);

// [S&M] Sets an integer preference (look in project prefs first, then in general prefs). Returns false if failed (e.g. varname not found).
REAPERAPI_DECL bool (*SNM_SetIntConfigVar)(const char* varname, int newvalue);

// [S&M] Returns a double preference (look in project prefs first, then in general prefs). Returns errvalue if failed (e.g. varname not found).
REAPERAPI_DECL double (*SNM_GetDoubleConfigVar)(const char* varname, double errvalue);

// [S&M] Sets a double preference (look in project prefs first, then in general prefs). Returns false if failed (e.g. varname not found).
REAPERAPI_DECL bool (*SNM_SetDoubleConfigVar)(const char* varname, double newvalue);

// [S&M] Move or removes a track FX. Returns true if tr has been updated.
// fxId: fx index in chain or -1 for the selected fx. what: 0 to remove, -1 to move fx up in chain, 1 to move fx down in chain.
REAPERAPI_DECL bool (*SNM_MoveOrRemoveTrackFX)(MediaTrack* tr, int fxId, int what);

// [S&M] Gets a marker/region name. Returns true if marker/region found.
REAPERAPI_DECL bool (*SNM_GetProjectMarkerName)(ReaProject* proj, int num, bool isrgn, WDL_FastString* name);

// [S&M] See SetProjectMarker3, it is the same function but this one can set empty names, i.e. "".
REAPERAPI_DECL bool (*SNM_SetProjectMarker)(ReaProject* proj, int num, bool isrgn, double pos, double rgnend, const char* name, int color);

// [S&M] Select a bookmark of the Resources window. Returns the related bookmark id (or -1 if failed).
REAPERAPI_DECL int (*SNM_SelectResourceBookmark)(const char* name);

// [S&M] Attach Resources slot actions to a given bookmark.
REAPERAPI_DECL void (*SNM_TieResourceSlotActions)(int bookmarkId);

// [S&M] Add an FX parameter knob in the TCP. Returns false if nothing updated (invalid parameters, knob already present, etc..)
REAPERAPI_DECL bool (*SNM_AddTCPFXParm)(MediaTrack* tr, int fxId, int prmId);

// [FNG] Allocate a RprMidiTake from a take pointer. Returns a NULL pointer if the take is not an in-project MIDI take
REAPERAPI_DECL RprMidiTake* (*FNG_AllocMidiTake)(MediaItem_Take* take);

// [FNG] Commit changes to MIDI take and free allocated memory
REAPERAPI_DECL void (*FNG_FreeMidiTake)(RprMidiTake* midiTake);

// [FNG] Count of how many MIDI notes are in the MIDI take
REAPERAPI_DECL int (*FNG_CountMidiNotes)(RprMidiTake* midiTake);

// [FNG] Get a MIDI note from a MIDI take at specified index
REAPERAPI_DECL RprMidiNote* (*FNG_GetMidiNote)(RprMidiTake* midiTake, int index);

// [FNG] Get MIDI note property
REAPERAPI_DECL int (*FNG_GetMidiNoteIntProperty)(RprMidiNote* midiNote, const char* property);

// [FNG] Set MIDI note property
REAPERAPI_DECL void (*FNG_SetMidiNoteIntProperty)(RprMidiNote* midiNote, const char* property, int value);

// [FNG] Add MIDI note to MIDI take
REAPERAPI_DECL RprMidiNote* (*FNG_AddMidiNote)(RprMidiTake* midiTake);

#ifdef REAPER_PLUGIN_FUNCTIONS_IMPL_LOADFUNC
#ifdef __RPFI
#error oops __RPFI already defined?!
#endif
int REAPERAPI_LoadAPI(void *(*getAPI)(const char *))
{
  #define __RPFI(x) {(void**)&x,#x},
  struct { void **dest; const char *name; } table[]={
    __RPFI(__mergesort) __RPFI(AddCustomizableMenu) __RPFI(AddExtensionsMainMenu) __RPFI(AddMediaItemToTrack) 
    __RPFI(AddProjectMarker) __RPFI(AddProjectMarker2) __RPFI(AddTakeToMediaItem) __RPFI(AddTempoTimeSigMarker) 
    __RPFI(adjustZoom) __RPFI(AnyTrackSolo) __RPFI(APITest) __RPFI(ApplyNudge) 
    __RPFI(Audio_IsPreBuffer) __RPFI(Audio_IsRunning) __RPFI(Audio_RegHardwareHook) __RPFI(BypassFxAllTracks) 
    __RPFI(CalculatePeaks) __RPFI(CalculatePeaksFloatSrcPtr) __RPFI(ClearAllRecArmed) __RPFI(ClearPeakCache) 
    __RPFI(CountActionShortcuts) __RPFI(CountMediaItems) __RPFI(CountSelectedMediaItems) __RPFI(CountSelectedTracks) 
    __RPFI(CountTakes) __RPFI(CountTCPFXParms) __RPFI(CountTempoTimeSigMarkers) __RPFI(CountTrackEnvelopes) 
    __RPFI(CountTrackMediaItems) __RPFI(CountTracks) __RPFI(CreateLocalOscHandler) __RPFI(CreateMIDIInput) 
    __RPFI(CreateMIDIOutput) __RPFI(CreateNewMIDIItemInProj) __RPFI(CreateTakeAudioAccessor) __RPFI(CreateTrackAudioAccessor) 
    __RPFI(CSurf_FlushUndo) __RPFI(CSurf_GetTouchState) __RPFI(CSurf_GoEnd) __RPFI(CSurf_GoStart) 
    __RPFI(CSurf_NumTracks) __RPFI(CSurf_OnArrow) __RPFI(CSurf_OnFwd) __RPFI(CSurf_OnFXChange) 
    __RPFI(CSurf_OnInputMonitorChange) __RPFI(CSurf_OnInputMonitorChangeEx) __RPFI(CSurf_OnMuteChange) __RPFI(CSurf_OnMuteChangeEx) 
    __RPFI(CSurf_OnOscControlMessage) __RPFI(CSurf_OnPanChange) __RPFI(CSurf_OnPanChangeEx) __RPFI(CSurf_OnPause) 
    __RPFI(CSurf_OnPlay) __RPFI(CSurf_OnPlayRateChange) __RPFI(CSurf_OnRecArmChange) __RPFI(CSurf_OnRecArmChangeEx) 
    __RPFI(CSurf_OnRecord) __RPFI(CSurf_OnRecvPanChange) __RPFI(CSurf_OnRecvVolumeChange) __RPFI(CSurf_OnRew) 
    __RPFI(CSurf_OnRewFwd) __RPFI(CSurf_OnScroll) __RPFI(CSurf_OnSelectedChange) __RPFI(CSurf_OnSendPanChange) 
    __RPFI(CSurf_OnSendVolumeChange) __RPFI(CSurf_OnSoloChange) __RPFI(CSurf_OnSoloChangeEx) __RPFI(CSurf_OnStop) 
    __RPFI(CSurf_OnTempoChange) __RPFI(CSurf_OnTrackSelection) __RPFI(CSurf_OnVolumeChange) __RPFI(CSurf_OnVolumeChangeEx) 
    __RPFI(CSurf_OnWidthChange) __RPFI(CSurf_OnWidthChangeEx) __RPFI(CSurf_OnZoom) __RPFI(CSurf_ResetAllCachedVolPanStates) 
    __RPFI(CSurf_ScrubAmt) __RPFI(CSurf_SetAutoMode) __RPFI(CSurf_SetPlayState) __RPFI(CSurf_SetRepeatState) 
    __RPFI(CSurf_SetSurfaceMute) __RPFI(CSurf_SetSurfacePan) __RPFI(CSurf_SetSurfaceRecArm) __RPFI(CSurf_SetSurfaceSelected) 
    __RPFI(CSurf_SetSurfaceSolo) __RPFI(CSurf_SetSurfaceVolume) __RPFI(CSurf_SetTrackListChange) __RPFI(CSurf_TrackFromID) 
    __RPFI(CSurf_TrackToID) __RPFI(DB2SLIDER) __RPFI(DeleteActionShortcut) __RPFI(DeleteExtState) 
    __RPFI(DeleteProjectMarker) __RPFI(DeleteTrack) __RPFI(DeleteTrackMediaItem) __RPFI(DestroyAudioAccessor) 
    __RPFI(DestroyLocalOscHandler) __RPFI(DoActionShortcutDialog) __RPFI(Dock_UpdateDockID) __RPFI(DockIsChildOfDock) 
    __RPFI(DockWindowActivate) __RPFI(DockWindowAdd) __RPFI(DockWindowAddEx) __RPFI(DockWindowRefresh) 
    __RPFI(DockWindowRefreshForHWND) __RPFI(DockWindowRemove) __RPFI(DuplicateCustomizableMenu) __RPFI(EnsureNotCompletelyOffscreen) 
    __RPFI(EnumPitchShiftModes) __RPFI(EnumPitchShiftSubModes) __RPFI(EnumProjectMarkers) __RPFI(EnumProjectMarkers2) 
    __RPFI(EnumProjectMarkers3) __RPFI(EnumProjects) __RPFI(EnumRegionRenderMatrix) __RPFI(EnumTrackMIDIProgramNames) 
    __RPFI(EnumTrackMIDIProgramNamesEx) __RPFI(file_exists) __RPFI(format_timestr) __RPFI(format_timestr_len) 
    __RPFI(format_timestr_pos) __RPFI(FreeHeapPtr) __RPFI(genGuid) __RPFI(get_config_var) 
    __RPFI(get_ini_file) __RPFI(get_midi_config_var) __RPFI(GetActionShortcutDesc) __RPFI(GetActiveTake) 
    __RPFI(GetAppVersion) __RPFI(GetAudioAccessorEndTime) __RPFI(GetAudioAccessorHash) __RPFI(GetAudioAccessorSamples) 
    __RPFI(GetAudioAccessorStartTime) __RPFI(GetColorTheme) __RPFI(GetColorThemeStruct) __RPFI(GetConfigWantsDock) 
    __RPFI(GetContextMenu) __RPFI(GetCurrentProjectInLoadSave) __RPFI(GetCursorContext) __RPFI(GetCursorPosition) 
    __RPFI(GetCursorPositionEx) __RPFI(GetDisplayedMediaItemColor) __RPFI(GetDisplayedMediaItemColor2) __RPFI(GetEnvelopeName) 
    __RPFI(GetExePath) __RPFI(GetExtState) __RPFI(GetFocusedFX) __RPFI(GetHZoomLevel) 
    __RPFI(GetIconThemePointer) __RPFI(GetIconThemeStruct) __RPFI(GetInputChannelName) __RPFI(GetItemEditingTime2) 
    __RPFI(GetItemProjectContext) __RPFI(GetLastTouchedFX) __RPFI(GetLastTouchedTrack) __RPFI(GetMainHwnd) 
    __RPFI(GetMasterMuteSoloFlags) __RPFI(GetMasterTrack) __RPFI(GetMasterTrackVisibility) __RPFI(GetMaxMidiInputs) 
    __RPFI(GetMaxMidiOutputs) __RPFI(GetMediaItem) __RPFI(GetMediaItem_Track) __RPFI(GetMediaItemInfo_Value) 
    __RPFI(GetMediaItemNumTakes) __RPFI(GetMediaItemTake) __RPFI(GetMediaItemTake_Item) __RPFI(GetMediaItemTake_Source) 
    __RPFI(GetMediaItemTake_Track) __RPFI(GetMediaItemTakeByGUID) __RPFI(GetMediaItemTakeInfo_Value) __RPFI(GetMediaItemTrack) 
    __RPFI(GetMediaSourceFileName) __RPFI(GetMediaSourceNumChannels) __RPFI(GetMediaSourceSampleRate) __RPFI(GetMediaSourceType) 
    __RPFI(GetMediaTrackInfo_Value) __RPFI(GetMidiInput) __RPFI(GetMIDIInputName) __RPFI(GetMidiOutput) 
    __RPFI(GetMIDIOutputName) __RPFI(GetMixerScroll) __RPFI(GetMouseModifier) __RPFI(GetNumAudioInputs) 
    __RPFI(GetNumAudioOutputs) __RPFI(GetNumMIDIInputs) __RPFI(GetNumMIDIOutputs) __RPFI(GetNumTracks) 
    __RPFI(GetOutputChannelName) __RPFI(GetOutputLatency) __RPFI(GetParentTrack) __RPFI(GetPeakFileName) 
    __RPFI(GetPeaksBitmap) __RPFI(GetPlayPosition) __RPFI(GetPlayPosition2) __RPFI(GetPlayPosition2Ex) 
    __RPFI(GetPlayPositionEx) __RPFI(GetPlayState) __RPFI(GetPlayStateEx) __RPFI(GetProjectPath) 
    __RPFI(GetProjectPathEx) __RPFI(GetProjectStateChangeCount) __RPFI(GetProjectTimeSignature) __RPFI(GetProjectTimeSignature2) 
    __RPFI(GetResourcePath) __RPFI(GetSelectedMediaItem) __RPFI(GetSelectedTrack) __RPFI(GetSelectedTrackEnvelope) 
    __RPFI(GetSet_ArrangeView2) __RPFI(GetSet_LoopTimeRange) __RPFI(GetSet_LoopTimeRange2) __RPFI(GetSetEnvelopeState) 
    __RPFI(GetSetEnvelopeState2) __RPFI(GetSetItemState) __RPFI(GetSetItemState2) __RPFI(GetSetMediaItemInfo) 
    __RPFI(GetSetMediaItemTakeInfo) __RPFI(GetSetMediaItemTakeInfo_String) __RPFI(GetSetMediaTrackInfo) __RPFI(GetSetMediaTrackInfo_String) 
    __RPFI(GetSetObjectState) __RPFI(GetSetObjectState2) __RPFI(GetSetRepeat) __RPFI(GetSetRepeatEx) 
    __RPFI(GetSetTrackMIDISupportFile) __RPFI(GetSetTrackSendInfo) __RPFI(GetSetTrackState) __RPFI(GetSetTrackState2) 
    __RPFI(GetSubProjectFromSource) __RPFI(GetTake) __RPFI(GetTakeEnvelopeByName) __RPFI(GetTakeName) 
    __RPFI(GetTCPFXParm) __RPFI(GetTempoMatchPlayRate) __RPFI(GetTempoTimeSigMarker) __RPFI(GetToggleCommandState) 
    __RPFI(GetToggleCommandState2) __RPFI(GetTooltipWindow) __RPFI(GetTrack) __RPFI(GetTrackAutomationMode) 
    __RPFI(GetTrackColor) __RPFI(GetTrackDepth) __RPFI(GetTrackEnvelope) __RPFI(GetTrackEnvelopeByName) 
    __RPFI(GetTrackGUID) __RPFI(GetTrackInfo) __RPFI(GetTrackMediaItem) __RPFI(GetTrackMIDINoteName) 
    __RPFI(GetTrackMIDINoteNameEx) __RPFI(GetTrackNumMediaItems) __RPFI(GetTrackNumSends) __RPFI(GetTrackReceiveName) 
    __RPFI(GetTrackReceiveUIMute) __RPFI(GetTrackReceiveUIVolPan) __RPFI(GetTrackSendName) __RPFI(GetTrackSendUIMute) 
    __RPFI(GetTrackSendUIVolPan) __RPFI(GetTrackState) __RPFI(GetTrackUIMute) __RPFI(GetTrackUIPan) 
    __RPFI(GetTrackUIVolPan) __RPFI(GetUserFileNameForRead) __RPFI(GetUserInputs) __RPFI(GR_SelectColor) 
    __RPFI(GSC_mainwnd) __RPFI(guidToString) __RPFI(HasExtState) __RPFI(HasTrackMIDIPrograms) 
    __RPFI(HasTrackMIDIProgramsEx) __RPFI(Help_Set) __RPFI(HiresPeaksFromSource) __RPFI(InsertMedia) 
    __RPFI(InsertMediaSection) __RPFI(InsertTrackAtIndex) __RPFI(IsInRealTimeAudio) __RPFI(IsItemTakeActiveForPlayback) 
    __RPFI(IsMediaExtension) __RPFI(IsMediaItemSelected) __RPFI(IsTrackSelected) __RPFI(IsTrackVisible) 
    __RPFI(kbd_enumerateActions) __RPFI(kbd_formatKeyName) __RPFI(kbd_getCommandName) __RPFI(kbd_getTextFromCmd) 
    __RPFI(KBD_OnMainActionEx) __RPFI(kbd_OnMidiEvent) __RPFI(kbd_OnMidiList) __RPFI(kbd_ProcessActionsMenu) 
    __RPFI(kbd_processMidiEventActionEx) __RPFI(kbd_reprocessMenu) __RPFI(kbd_RunCommandThroughHooks) __RPFI(kbd_translateAccelerator) 
    __RPFI(kbd_translateMouse) __RPFI(LICE__Destroy) __RPFI(LICE__DestroyFont) __RPFI(LICE__DrawText) 
    __RPFI(LICE__GetBits) __RPFI(LICE__GetDC) __RPFI(LICE__GetHeight) __RPFI(LICE__GetRowSpan) 
    __RPFI(LICE__GetWidth) __RPFI(LICE__IsFlipped) __RPFI(LICE__resize) __RPFI(LICE__SetBkColor) 
    __RPFI(LICE__SetFromHFont) __RPFI(LICE__SetTextColor) __RPFI(LICE__SetTextCombineMode) __RPFI(LICE_Arc) 
    __RPFI(LICE_Blit) __RPFI(LICE_Blur) __RPFI(LICE_BorderedRect) __RPFI(LICE_Circle) 
    __RPFI(LICE_Clear) __RPFI(LICE_ClearRect) __RPFI(LICE_ClipLine) __RPFI(LICE_Copy) 
    __RPFI(LICE_CreateBitmap) __RPFI(LICE_CreateFont) __RPFI(LICE_DrawChar) __RPFI(LICE_DrawGlyph) 
    __RPFI(LICE_DrawRect) __RPFI(LICE_DrawText) __RPFI(LICE_FillCircle) __RPFI(LICE_FillConvexPolygon) 
    __RPFI(LICE_FillRect) __RPFI(LICE_FillTrapezoid) __RPFI(LICE_FillTriangle) __RPFI(LICE_GetPixel) 
    __RPFI(LICE_GradRect) __RPFI(LICE_Line) __RPFI(LICE_LineInt) __RPFI(LICE_LoadPNG) 
    __RPFI(LICE_LoadPNGFromResource) __RPFI(LICE_MeasureText) __RPFI(LICE_MultiplyAddRect) __RPFI(LICE_PutPixel) 
    __RPFI(LICE_RotatedBlit) __RPFI(LICE_RoundRect) __RPFI(LICE_ScaledBlit) __RPFI(LICE_SimpleFill) 
    __RPFI(Loop_OnArrow) __RPFI(Main_OnCommand) __RPFI(Main_OnCommandEx) __RPFI(Main_openProject) 
    __RPFI(Main_UpdateLoopInfo) __RPFI(MarkProjectDirty) __RPFI(MarkTrackItemsDirty) __RPFI(Master_GetPlayRate) 
    __RPFI(Master_GetPlayRateAtTime) __RPFI(Master_GetTempo) __RPFI(Master_NormalizePlayRate) __RPFI(Master_NormalizeTempo) 
    __RPFI(MB) __RPFI(MediaItemDescendsFromTrack) __RPFI(MIDI_eventlist_Create) __RPFI(MIDI_eventlist_Destroy) 
    __RPFI(midi_reinit) __RPFI(MIDIEditor_GetActive) __RPFI(MIDIEditor_GetMode) __RPFI(MIDIEditor_GetTake) 
    __RPFI(MIDIEditor_LastFocused_OnCommand) __RPFI(MIDIEditor_OnCommand) __RPFI(mkpanstr) __RPFI(mkvolpanstr) 
    __RPFI(mkvolstr) __RPFI(MoveEditCursor) __RPFI(MoveMediaItemToTrack) __RPFI(MuteAllTracks) 
    __RPFI(my_getViewport) __RPFI(NamedCommandLookup) __RPFI(OnPauseButton) __RPFI(OnPauseButtonEx) 
    __RPFI(OnPlayButton) __RPFI(OnPlayButtonEx) __RPFI(OnStopButton) __RPFI(OnStopButtonEx) 
    __RPFI(OscLocalMessageToHost) __RPFI(parse_timestr) __RPFI(parse_timestr_len) __RPFI(parse_timestr_pos) 
    __RPFI(parsepanstr) __RPFI(PCM_Sink_Create) __RPFI(PCM_Sink_CreateEx) __RPFI(PCM_Sink_CreateMIDIFile) 
    __RPFI(PCM_Sink_CreateMIDIFileEx) __RPFI(PCM_Sink_Enum) __RPFI(PCM_Sink_GetExtension) __RPFI(PCM_Sink_ShowConfig) 
    __RPFI(PCM_Source_CreateFromFile) __RPFI(PCM_Source_CreateFromFileEx) __RPFI(PCM_Source_CreateFromSimple) __RPFI(PCM_Source_CreateFromType) 
    __RPFI(PCM_Source_GetSectionInfo) __RPFI(PeakBuild_Create) __RPFI(PeakGet_Create) __RPFI(PlayPreview) 
    __RPFI(PlayPreviewEx) __RPFI(PlayTrackPreview) __RPFI(PlayTrackPreview2) __RPFI(PlayTrackPreview2Ex) 
    __RPFI(plugin_getapi) __RPFI(plugin_getFilterList) __RPFI(plugin_getImportableProjectFilterList) __RPFI(plugin_register) 
    __RPFI(PluginWantsAlwaysRunFx) __RPFI(PreventUIRefresh) __RPFI(projectconfig_var_addr) __RPFI(projectconfig_var_getoffs) 
    __RPFI(ReaperGetPitchShiftAPI) __RPFI(ReaScriptError) __RPFI(RecursiveCreateDirectory) __RPFI(RefreshToolbar) 
    __RPFI(relative_fn) __RPFI(RenderFileSection) __RPFI(Resample_EnumModes) __RPFI(Resampler_Create) 
    __RPFI(resolve_fn) __RPFI(screenset_register) __RPFI(screenset_registerNew) __RPFI(screenset_unregister) 
    __RPFI(screenset_unregisterByParam) __RPFI(SectionFromUniqueID) __RPFI(SelectAllMediaItems) __RPFI(SelectProjectInstance) 
    __RPFI(SendLocalOscMessage) __RPFI(SetActiveTake) __RPFI(SetAutomationMode) __RPFI(SetCurrentBPM) 
    __RPFI(SetEditCurPos) __RPFI(SetEditCurPos2) __RPFI(SetExtState) __RPFI(SetMasterTrackVisibility) 
    __RPFI(SetMediaItemInfo_Value) __RPFI(SetMediaItemLength) __RPFI(SetMediaItemPosition) __RPFI(SetMediaItemSelected) 
    __RPFI(SetMediaItemTakeInfo_Value) __RPFI(SetMediaTrackInfo_Value) __RPFI(SetMixerScroll) __RPFI(SetMouseModifier) 
    __RPFI(SetOnlyTrackSelected) __RPFI(SetProjectMarker) __RPFI(SetProjectMarker2) __RPFI(SetProjectMarker3) 
    __RPFI(SetRegionRenderMatrix) __RPFI(SetRenderLastError) __RPFI(SetTempoTimeSigMarker) __RPFI(SetTrackAutomationMode) 
    __RPFI(SetTrackColor) __RPFI(SetTrackMIDINoteName) __RPFI(SetTrackMIDINoteNameEx) __RPFI(SetTrackSelected) 
    __RPFI(SetTrackSendUIPan) __RPFI(SetTrackSendUIVol) __RPFI(ShowActionList) __RPFI(ShowConsoleMsg) 
    __RPFI(ShowMessageBox) __RPFI(SLIDER2DB) __RPFI(SnapToGrid) __RPFI(SoloAllTracks) 
    __RPFI(SplitMediaItem) __RPFI(StopPreview) __RPFI(StopTrackPreview) __RPFI(StopTrackPreview2) 
    __RPFI(stringToGuid) __RPFI(TimeMap2_beatsToTime) __RPFI(TimeMap2_GetDividedBpmAtTime) __RPFI(TimeMap2_GetNextChangeTime) 
    __RPFI(TimeMap2_QNToTime) __RPFI(TimeMap2_timeToBeats) __RPFI(TimeMap2_timeToQN) __RPFI(TimeMap_GetDividedBpmAtTime) 
    __RPFI(TimeMap_GetTimeSigAtTime) __RPFI(TimeMap_QNToTime) __RPFI(TimeMap_timeToQN) __RPFI(ToggleTrackSendUIMute) 
    __RPFI(Track_GetPeakHoldDB) __RPFI(Track_GetPeakInfo) __RPFI(TrackCtl_SetToolTip) __RPFI(TrackFX_EndParamEdit) 
    __RPFI(TrackFX_FormatParamValue) __RPFI(TrackFX_FormatParamValueNormalized) __RPFI(TrackFX_GetByName) __RPFI(TrackFX_GetChainVisible) 
    __RPFI(TrackFX_GetCount) __RPFI(TrackFX_GetEnabled) __RPFI(TrackFX_GetEQ) __RPFI(TrackFX_GetEQBandEnabled) 
    __RPFI(TrackFX_GetEQParam) __RPFI(TrackFX_GetFloatingWindow) __RPFI(TrackFX_GetFormattedParamValue) __RPFI(TrackFX_GetFXGUID) 
    __RPFI(TrackFX_GetFXName) __RPFI(TrackFX_GetInstrument) __RPFI(TrackFX_GetNumParams) __RPFI(TrackFX_GetOpen) 
    __RPFI(TrackFX_GetParam) __RPFI(TrackFX_GetParameterStepSizes) __RPFI(TrackFX_GetParamEx) __RPFI(TrackFX_GetParamName) 
    __RPFI(TrackFX_GetParamNormalized) __RPFI(TrackFX_GetPreset) __RPFI(TrackFX_GetPresetIndex) __RPFI(TrackFX_NavigatePresets) 
    __RPFI(TrackFX_SetEnabled) __RPFI(TrackFX_SetEQBandEnabled) __RPFI(TrackFX_SetEQParam) __RPFI(TrackFX_SetOpen) 
    __RPFI(TrackFX_SetParam) __RPFI(TrackFX_SetParamNormalized) __RPFI(TrackFX_SetPreset) __RPFI(TrackFX_SetPresetByIndex) 
    __RPFI(TrackFX_Show) __RPFI(TrackList_AdjustWindows) __RPFI(TrackList_UpdateAllExternalSurfaces) __RPFI(Undo_BeginBlock) 
    __RPFI(Undo_BeginBlock2) __RPFI(Undo_CanRedo2) __RPFI(Undo_CanUndo2) __RPFI(Undo_DoRedo2) 
    __RPFI(Undo_DoUndo2) __RPFI(Undo_EndBlock) __RPFI(Undo_EndBlock2) __RPFI(Undo_OnStateChange) 
    __RPFI(Undo_OnStateChange2) __RPFI(Undo_OnStateChange_Item) __RPFI(Undo_OnStateChangeEx) __RPFI(Undo_OnStateChangeEx2) 
    __RPFI(UpdateArrange) __RPFI(UpdateItemInProject) __RPFI(UpdateTimeline) __RPFI(ValidatePtr) 
    __RPFI(ViewPrefs) __RPFI(WDL_VirtualWnd_ScaledBlitBG) __RPFI(SNM_CreateFastString) __RPFI(SNM_DeleteFastString) 
    __RPFI(SNM_GetFastString) __RPFI(SNM_GetFastStringLength) __RPFI(SNM_SetFastString) __RPFI(SNM_GetMediaItemTakeByGUID) 
    __RPFI(SNM_GetSourceType) __RPFI(SNM_GetSetSourceState) __RPFI(SNM_GetSetSourceState2) __RPFI(SNM_GetSetObjectState) 
    __RPFI(SNM_AddReceive) __RPFI(SNM_RemoveReceive) __RPFI(SNM_RemoveReceivesFrom) __RPFI(SNM_GetIntConfigVar) 
    __RPFI(SNM_SetIntConfigVar) __RPFI(SNM_GetDoubleConfigVar) __RPFI(SNM_SetDoubleConfigVar) __RPFI(SNM_MoveOrRemoveTrackFX) 
    __RPFI(SNM_GetProjectMarkerName) __RPFI(SNM_SetProjectMarker) __RPFI(SNM_SelectResourceBookmark) __RPFI(SNM_TieResourceSlotActions) 
    __RPFI(SNM_AddTCPFXParm) __RPFI(FNG_AllocMidiTake) __RPFI(FNG_FreeMidiTake) __RPFI(FNG_CountMidiNotes) 
    __RPFI(FNG_GetMidiNote) __RPFI(FNG_GetMidiNoteIntProperty) __RPFI(FNG_SetMidiNoteIntProperty) __RPFI(FNG_AddMidiNote) 
  };
  int i,failcnt=0;
  for (i=0;i<sizeof(table)/sizeof(table[0]); i++)
    failcnt += !(*table[i].dest = getAPI(table[i].name));
  return failcnt;
  #undef __RPFI
}
#endif //REAPER_PLUGIN_FUNCTIONS_IMPL_LOADFUNC
#endif // _REAPER_PLUGIN_FUNCTIONS_H_

